<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spelling Bee Showdown</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117;
            color: #c9d1d9;
        }
        .container {
            max-width: 1200px;
            margin: auto;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 2rem;
        }
        .word-input {
            font-size: 1.5rem;
            padding: 0.75rem;
            border-radius: 0.5rem;
            text-align: center;
        }
        .text-neon-blue {
            color: #00e0ff;
        }
        .bg-gradient-to-r-blue-green {
            background-image: linear-gradient(to right, #00e0ff, #00ff7f);
        }
        .glow {
            filter: drop-shadow(0 0 5px #00e0ff);
        }
        .button-glow:hover {
            box-shadow: 0 0 10px #00e0ff;
        }
        .player-card {
            padding: 1.5rem;
            border-radius: 1rem;
            background-color: #161b22;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 224, 255, 0.1);
        }
        .player-card.active {
            border: 3px solid #00e0ff;
            box-shadow: 0 0 20px #00e0ff, inset 0 0 10px #00e0ff;
            transform: scale(1.05);
        }
        .player-card.winner {
            background-color: #00ff7f;
            color: #0d1117;
            font-weight: bold;
        }

        /* Bracket styles */
        .bracket-container {
            display: flex;
            justify-content: space-around;
            align-items: center;
            flex-wrap: nowrap;
            overflow-x: auto;
        }
        .round {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 1rem 0.5rem;
            padding: 1rem;
        }
        .matchup {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0.5rem;
            background-color: #161b22;
            border-radius: 0.5rem;
            border: 1px solid #2d333b;
            position: relative;
        }
        .player-name {
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .matchup:after, .matchup:before {
            content: '';
            position: absolute;
            background-color: #4b5563;
        }
        .matchup:after {
            top: 50%;
            left: 100%;
            height: 2px;
            width: 1rem;
        }
        .matchup:before {
            top: 50%;
            left: 100%;
            height: calc(100% + 1rem);
            width: 2px;
            transform: translateY(-50%);
        }
        .round:not(:last-child) .matchup:after {
            height: 0;
            width: 0;
        }
        .round:not(:first-child) .matchup:before {
            display: none;
        }
        .round:not(:first-child) .matchup:after {
            left: -1rem;
            transform: translateY(-50%);
        }
        .round:first-child .matchup:after {
            width: 0;
        }
        .round-connector {
            position: relative;
            width: 1rem;
            height: 2px;
            background-color: #4b5563;
        }
        .round-connector.vertical {
            width: 2px;
            height: 1rem;
        }
        .winner-player {
            background-color: #00ff7f;
            color: #0d1117;
            font-weight: bold;
        }
        .loser-player {
            color: #6b7280;
        }
    </style>
</head>
<body class="bg-[#0d1117] text-[#c9d1d9]">
    <div class="container lg:flex-row lg:items-start lg:space-x-8">
        <!-- Start Screen -->
        <div id="start-screen" class="w-full max-w-lg p-8 rounded-2xl bg-[#161b22] shadow-2xl transition-all duration-500">
            <h1 class="text-4xl md:text-5xl font-extrabold text-center text-neon-blue mb-6 glow">Spelling Bee Showdown</h1>
            <div class="mb-4">
                <label for="player-count" class="block text-sm font-medium mb-1">Number of Players (2-16):</label>
                <input type="number" id="player-count" class="w-full p-2 rounded-lg bg-[#0d1117] text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-neon-blue" value="4" min="2" max="16">
            </div>
            <div class="mb-4">
                <label for="max-difficulty" class="block text-sm font-medium mb-1">Maximum Difficulty:</label>
                <select id="max-difficulty" class="w-full p-2 rounded-lg bg-[#0d1117] text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-neon-blue">
                    <option value="A1">A1</option>
                    <option value="A2">A2</option>
                    <option value="B1">B1</option>
                    <option value="B2">B2</option>
                </select>
            </div>
            <div id="player-inputs" class="mb-6 space-y-2">
                <!-- Player name inputs will be dynamically added here -->
            </div>
            <button id="start-button" class="w-full py-3 rounded-lg text-white font-bold text-lg bg-gradient-to-r-blue-green button-glow transition-transform duration-300 hover:scale-105">Start Game</button>
        </div>

        <!-- Game & Bracket View -->
        <div id="game-and-brackets" class="hidden w-full lg:flex lg:flex-row lg:items-start lg:space-x-8 mt-8 lg:mt-0">
            <!-- Game Screen -->
            <div id="game-screen" class="flex-1 w-full max-w-full">
                <h2 id="round-title" class="text-3xl font-extrabold text-center text-white mb-6"></h2>
                
                <!-- Duel Section (for bracket play) -->
                <div id="duel-section" class="w-full max-w-2xl p-8 rounded-2xl bg-[#161b22] shadow-2xl transition-all duration-500">
                    <div class="flex justify-around items-center mb-6">
                        <div id="player1-card" class="player-card text-center">
                            <p id="player1-name" class="text-2xl font-semibold"></p>
                        </div>
                        <p class="text-2xl font-bold text-neon-blue">VS</p>
                        <div id="player2-card" class="player-card text-center">
                            <p id="player2-name" class="text-2xl font-semibold"></p>
                        </div>
                    </div>

                    <div class="text-center mb-6">
                        <p id="current-player-turn" class="text-xl font-semibold"></p>
                        <p id="word-level" class="text-lg font-medium text-gray-400 mt-2"></p>
                    </div>

                    <div class="flex flex-col items-center justify-center space-y-4">
                        <div class="text-center mb-4">
                            <p id="mc-word" class="hidden text-3xl font-bold text-white mb-2"></p>
                            <button id="toggle-word-button" class="mt-2 py-2 px-4 rounded-lg bg-gray-600 text-white hover:bg-gray-700 transition-colors">Show Word</button>
                        </div>
                        
                        <input type="text" id="spelling-input" class="word-input w-full md:w-3/4 bg-[#0d1117] text-white border-2 border-transparent focus:outline-none focus:border-neon-blue transition-all duration-300" placeholder="Type the word here...">
                        <div class="flex justify-center items-center space-x-6 w-full">
                            <div class="flex items-center space-x-2">
                                <svg class="w-6 h-6 text-neon-blue" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                                <span id="stopwatch" class="text-xl font-bold">00:00:00</span>
                            </div>
                            <div class="flex items-center space-x-2">
                                <svg class="w-6 h-6 text-neon-blue" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg>
                                <span id="backspace-count" class="text-xl font-bold">0</span>
                            </div>
                        </div>
                        <button id="submit-button" class="w-full md:w-1/2 py-3 rounded-lg text-white font-bold text-lg bg-gradient-to-r-blue-green button-glow transition-transform duration-300 hover:scale-105">Submit</button>
                    </div>
                </div>

                <!-- Qualifying Round Section (new) -->
                <div id="qualifying-section" class="hidden w-full max-w-2xl p-8 rounded-2xl bg-[#161b22] shadow-2xl transition-all duration-500">
                    <h3 id="qualifying-player-name" class="text-2xl font-semibold text-center mb-4"></h3>
                    <p class="text-lg font-medium text-gray-400 text-center" id="qualifying-word-level"></p>
                    
                    <div class="flex flex-col items-center justify-center space-y-4 mt-6">
                        <div class="text-center mb-4">
                            <p id="qualifying-mc-word" class="hidden text-3xl font-bold text-white mb-2"></p>
                            <button id="qualifying-toggle-word-button" class="mt-2 py-2 px-4 rounded-lg bg-gray-600 text-white hover:bg-gray-700 transition-colors">Show Word</button>
                        </div>
                        
                        <input type="text" id="qualifying-spelling-input" class="word-input w-full md:w-3/4 bg-[#0d1117] text-white border-2 border-transparent focus:outline-none focus:border-neon-blue transition-all duration-300" placeholder="Type the word here...">
                        <div class="flex justify-center items-center space-x-6 w-full">
                            <div class="flex items-center space-x-2">
                                <svg class="w-6 h-6 text-neon-blue" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                                <span id="qualifying-stopwatch" class="text-xl font-bold">00:00:00</span>
                            </div>
                            <div class="flex items-center space-x-2">
                                <svg class="w-6 h-6 text-neon-blue" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg>
                                <span id="qualifying-backspace-count" class="text-xl font-bold">0</span>
                            </div>
                        </div>
                        <button id="qualifying-submit-button" class="w-full md:w-1/2 py-3 rounded-lg text-white font-bold text-lg bg-gradient-to-r-blue-green button-glow transition-transform duration-300 hover:scale-105">Submit</button>
                    </div>

                    <div id="qualifying-scoreboard" class="mt-8">
                        <h4 class="text-xl font-bold text-center mb-4">Qualifying Scoreboard</h4>
                        <ul id="qualifying-list" class="space-y-2">
                            <!-- Scoreboard will be populated here -->
                        </ul>
                    </div>
                </div>

                <!-- Results Section -->
                <div id="results-section" class="hidden w-full max-w-xl mt-8 p-8 rounded-2xl bg-[#161b22] shadow-2xl transition-all duration-500">
                    <h3 class="text-2xl font-bold text-center mb-4">Duel Results</h3>
                    <div id="results-content" class="text-center">
                        <!-- Results will be dynamically populated here -->
                    </div>
                    <button id="next-duel-button" class="mt-6 w-full py-3 rounded-lg text-white font-bold text-lg bg-gradient-to-r-blue-green button-glow transition-transform duration-300 hover:scale-105 hidden">Next Duel</button>
                </div>

                <!-- Qualifying Results Section (new) -->
                <div id="qualifying-results-section" class="hidden w-full max-w-xl mt-8 p-8 rounded-2xl bg-[#161b22] shadow-2xl transition-all duration-500">
                    <h3 class="text-2xl font-bold text-center mb-4">Qualifying Round Results</h3>
                    <div id="qualifying-results-content" class="text-center">
                         <!-- Results will be dynamically populated here -->
                    </div>
                    <button id="start-bracket-button" class="mt-6 w-full py-3 rounded-lg text-white font-bold text-lg bg-gradient-to-r-blue-green button-glow transition-transform duration-300 hover:scale-105">Start Bracket</button>
                </div>
                
                <!-- Tournament View Buttons -->
                <div class="flex flex-col items-center mt-8 w-full max-w-2xl">
                    <button id="toggle-tournament-log-button" class="py-2 px-6 rounded-lg bg-gray-600 text-white hover:bg-gray-700 transition-colors">Show Tournament Log</button>
                    <div id="tournament-log" class="hidden w-full p-8 rounded-2xl bg-[#161b22] shadow-xl mt-4">
                        <h3 class="text-xl font-bold mb-4">Tournament Log</h3>
                        <div id="tournament-content" class="space-y-4">
                            <!-- Duel history will be populated here -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Bracket View -->
            <div id="bracket-view" class="flex-1 w-full p-8 rounded-2xl bg-[#161b22] shadow-2xl transition-all duration-500 overflow-x-auto mt-8 lg:mt-0">
                <h2 class="text-3xl font-extrabold text-center text-white mb-6">Tournament Brackets</h2>
                <div id="bracket-container" class="bracket-container">
                    <!-- Brackets will be rendered here -->
                </div>
            </div>
        </div>
        
        <!-- Champion Screen -->
        <div id="champion-screen" class="hidden w-full max-w-lg p-8 rounded-2xl bg-[#161b22] shadow-2xl text-center">
            <h1 class="text-6xl font-extrabold text-neon-blue mb-4 glow">Final Results</h1>
            <div id="medals" class="space-y-4 text-center">
                <div class="flex flex-col items-center">
                    <span class="text-5xl font-extrabold text-yellow-400">
                        <svg class="w-16 h-16 text-yellow-400" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a8 8 0 100 16 8 8 0 000-16zM6.92 14.88c.4.38.93.59 1.48.59.55 0 1.08-.21 1.48-.59l1.41-1.35c.42-.4.98-.63 1.58-.63.6 0 1.16.23 1.58.63l1.41 1.35c.4.38.93.59 1.48.59.55 0 1.08-.21 1.48-.59.88-.84 1.35-1.95 1.35-3.15 0-1.2-.47-2.31-1.35-3.15l-1.41-1.35c-.42-.4-.98-.63-1.58-.63-.6 0-1.16.23-1.58.63L10 8.16l-1.41-1.35c-.42-.4-.98-.63-1.58-.63-.6 0-1.16.23-1.58.63L5.27 8.16c-.88.84-1.35 1.95-1.35 3.15 0 1.2.47 2.31 1.35 3.15l1.41 1.35z"/></svg>
                    </span>
                    <p id="champion-name" class="text-4xl font-semibold mt-2"></p>
                    <p class="text-xl text-gray-400">Gold Medal</p>
                </div>
                <div class="flex flex-col items-center">
                    <span class="text-5xl font-extrabold text-gray-300">
                         <svg class="w-16 h-16 text-gray-300" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a8 8 0 100 16 8 8 0 000-16zM6.92 14.88c.4.38.93.59 1.48.59.55 0 1.08-.21 1.48-.59l1.41-1.35c.42-.4.98-.63 1.58-.63.6 0 1.16.23 1.58.63l1.41 1.35c.4.38.93.59 1.48.59.55 0 1.08-.21 1.48-.59.88-.84 1.35-1.95 1.35-3.15 0-1.2-.47-2.31-1.35-3.15l-1.41-1.35c-.42-.4-.98-.63-1.58-.63-.6 0-1.16.23-1.58.63L10 8.16l-1.41-1.35c-.42-.4-.98-.63-1.58-.63-.6 0-1.16.23-1.58.63L5.27 8.16c-.88.84-1.35 1.95-1.35 3.15 0 1.2.47 2.31 1.35 3.15l1.41 1.35z"/></svg>
                    </span>
                    <p id="silver-medal" class="text-2xl font-semibold mt-2"></p>
                    <p class="text-lg text-gray-400">Silver Medal</p>
                </div>
                <div class="flex flex-col items-center">
                    <span class="text-5xl font-extrabold text-orange-400">
                         <svg class="w-16 h-16 text-orange-400" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a8 8 0 100 16 8 8 0 000-16zM6.92 14.88c.4.38.93.59 1.48.59.55 0 1.08-.21 1.48-.59l1.41-1.35c.42-.4.98-.63 1.58-.63.6 0 1.16.23 1.58.63l1.41 1.35c.4.38.93.59 1.48.59.55 0 1.08-.21 1.48-.59.88-.84 1.35-1.95 1.35-3.15 0-1.2-.47-2.31-1.35-3.15l-1.41-1.35c-.42-.4-.98-.63-1.58-.63-.6 0-1.16.23-1.58.63L10 8.16l-1.41-1.35c-.42-.4-.98-.63-1.58-.63-.6 0-1.16.23-1.58.63L5.27 8.16c-.88.84-1.35 1.95-1.35 3.15 0 1.2.47 2.31 1.35 3.15l1.41 1.35z"/></svg>
                    </span>
                    <p id="bronze-medal" class="text-2xl font-semibold mt-2"></p>
                    <p class="text-lg text-gray-400">Bronze Medal</p>
                </div>
            </div>
            <button id="play-again-button" class="mt-6 w-full py-3 rounded-lg text-white font-bold text-lg bg-gradient-to-r-blue-green button-glow transition-transform duration-300 hover:scale-105">Play Again</button>
        </div>
    </div>

    <script>
        const WORDS_A1 = ["cat", "dog", "house", "car", "book", "pen", "desk", "chair", "table", "door", "window", "light", "bed", "lamp", "sofa", "phone", "bag", "box", "key", "cup", "plate", "fork", "spoon", "knife", "glass", "water", "juice", "milk", "bread", "apple", "banana", "orange", "grape", "lemon", "egg", "rice", "meat", "fish", "soup", "salad", "cheese", "butter", "sugar", "salt", "pepper", "tea", "coffee", "cake", "cookie", "pie", "baby", "child", "man", "woman", "boy", "girl", "friend", "family", "father", "mother", "sister", "brother", "son", "daughter", "hello", "goodbye", "please", "thank", "sorry", "yes", "no", "what", "where", "when", "why", "who", "how", "big", "small", "tall", "short", "long", "new", "old", "good", "bad", "hot", "cold", "happy", "sad", "angry", "tired", "hungry", "thirsty", "sick", "well", "walk", "run", "jump", "swim", "fly", "eat", "drink", "sleep", "read", "write", "talk", "sing", "dance", "play", "work", "study", "go", "come", "see", "hear", "smell", "taste", "touch", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety", "hundred", "first", "second", "third", "today", "tomorrow", "yesterday", "morning", "afternoon", "evening", "night", "winter", "spring", "summer", "autumn", "january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday", "red", "blue", "green", "yellow", "black", "white", "brown", "pink", "purple", "gray", "gold", "silver", "color", "animal", "plant", "tree", "flower", "grass", "sun", "moon", "star", "sky", "cloud", "rain", "snow", "wind", "weather", "town", "city", "country", "street", "road", "park", "shop", "bank", "school", "hospital", "police", "post", "office", "station", "airport", "train", "bus", "bike", "taxi", "ship", "boat", "plane", "engine", "wheel", "fuel", "money", "credit", "card", "cash", "market", "store", "supermarket", "mall", "clothes", "shirt", "pants", "dress", "skirt", "jacket", "coat", "shoes", "socks", "hat", "cap"];
        const WORDS_A2 = ["address", "airport", "amazing", "beautiful", "because", "bedroom", "believe", "birthday", "building", "calendar", "camera", "channel", "chicken", "chocolate", "cinema", "clothes", "computer", "country", "cousin", "daughter", "dictionary", "difficult", "doctor", "everybody", "excuse", "expensive", "family", "favorite", "favourite", "fifteen", "finally", "football", "friend", "future", "garden", "glasses", "goodbye", "grammar", "grandmother", "guitar", "holiday", "homework", "hospital", "important", "interesting", "jacket", "kitchen", "language", "learn", "listen", "magazine", "market", "morning", "museum", "newspaper", "notebook", "nothing", "opposite", "parents", "perfect", "person", "photograph", "picture", "practice", "prepare", "question", "remember", "restaurant", "sandwich", "science", "sentence", "shopping", "sister", "somebody", "something", "sometimes", "station", "student", "teacher", "telephone", "television", "thirteen", "thursday", "ticket", "together", "tomorrow", "tonight", "travel", "university", "vegetable", "village", "weather", "weekend", "welcome", "yesterday", "younger", "absolute", "accurate", "adventure", "agreement", "ambulance", "anywhere", "apartment", "attractive", "backwards", "breakfast", "business", "calculate", "careful", "celebrate", "championship", "community", "condition", "confident", "connection", "convenient", "conversation", "difficult", "direction", "education", "effective", "electrical", "especially", "everywhere", "excellent", "exercise", "experience", "explanation", "fantastic", "following", "forbidden", "foreign", "frequently", "furniture", "generous", "gentleman", "good-looking", "government", "happily", "happiness", "headache", "heartbroken", "historical", "honestly", "however", "illness", "imaginary", "immediately", "important", "impossible", "incredibly", "information", "instrument", "intelligent", "international", "introduction", "invitation", "irresponsible", "kilometre", "knowledge", "laughing", "leisure", "literature", "loneliness", "magazine", "management", "manhattan", "marathon", "material", "mathematics", "medication", "messenger", "motorcycle", "mountain", "musician", "necessary", "neighbourhood", "nervous", "opportunity", "organization", "participant", "passenger", "peacefully", "permission", "personally", "photographer", "pleasure", "population", "possibility", "powerful", "prescription", "professional", "protection", "punishment", "reasonable", "recognise", "recommend", "refrigerator", "regretfully", "relationship", "remarkable", "remember", "responsible", "romantic", "satisfied", "secretary", "selection", "serious", "similarly", "sincerely", "something", "specialise", "spectacular", "successful", "suggestion", "surprise", "swimming", "temperature", "terrible", "thousand", "together", "tomorrow", "unbelievable", "uncomfortable", "unforgettable", "unhealthy", "university", "unnecessary", "unusual", "valuable", "vegetable", "volunteer", "wonderful", "worker", "writing", "yesterday"];
        const WORDS_B1 = ["abolish", "accomplish", "acknowledge", "adolescence", "advantage", "agriculture", "anxious", "apologize", "appreciation", "approximately", "architecture", "artificial", "atmosphere", "attendance", "authority", "campaign", "celebration", "challenge", "characteristic", "civilization", "community", "complicated", "concentration", "conference", "consequence", "conservative", "contribution", "convenience", "cooperation", "correspondent", "creativity", "curiosity", "dedication", "demonstrate", "dependable", "depression", "description", "determination", "development", "disadvantage", "discipline", "dissatisfied", "distribute", "embarrassment", "employment", "enthusiasm", "environment", "especially", "establishment", "exaggerate", "excitement", "experience", "experiment", "explanation", "exploration", "fortunately", "frequently", "generosity", "government", "guarantee", "hospitality", "imagination", "immediately", "impression", "improvement", "independence", "individual", "information", "ingredients", "innovation", "insufficient", "intelligent", "interfere", "international", "introduction", "investment", "investigation", "involvement", "irresponsible", "judgment", "knowledge", "leadership", "literature", "management", "memorize", "necessary", "negotiation", "occasionally", "organization", "particularly", "perfection", "permission", "personality", "phenomenon", "philosophy", "popularity", "possibility", "preparation", "presentation", "preservation", "professional", "protection", "psychology", "recognize", "recommendation", "relationship", "reliable", "responsible", "satisfaction", "significant", "similarity", "sincerely", "society", "solution", "sophisticated", "specialist", "spectacular", "substance", "successful", "suggestion", "superstition", "surroundings", "technology", "temperature", "terrible", "tradition", "unfortunately", "unforgettable", "university", "unnecessary", "unusual", "valuable", "variation", "variety", "vegetable", "volunteer", "willingness", "wonderful", "yesterday", "youthful", "accommodate", "achievement", "adventure", "aggression", "analysis", "announcement", "anxiety", "application", "appreciation", "argument", "arrangement", "assistance", "association", "assumption", "availability", "awareness", "behaviour", "biography", "broadcast", "cancellation", "capacity", "celebrity", "challenge", "championship", "character", "chemistry", "coincidence", "commitment", "communication", "competition", "complaint", "concentration", "confidence", "connection", "consequence", "consideration", "consistency", "construction", "contribution", "convenience", "cooperation", "correction", "curiosity", "decision", "definitely", "demonstration", "departure", "description", "development", "difficulty", "disappointment", "discussion", "distinction", "diversity", "efficiency", "embarrassment", "emergency", "emotion", "employment", "energy", "enthusiasm", "environment", "evidence", "examination", "excitement", "existence", "explanation", "facility", "familiar", "flexibility", "forecast", "formation", "foundation", "frustration", "generosity", "government", "happiness", "imagination", "improvement", "independence", "individual", "information", "initiative", "insurance", "intelligence", "interaction", "interest", "introduction", "investigation", "involvement", "knowledge", "leadership", "lifestyle", "limitation", "location", "management", "material", "meaningful", "membership", "memory", "motivation", "negotiation", "obligation", "occupation", "opportunity", "organization", "passenger", "patience", "performance", "permission", "personality", "population", "possession", "potential", "poverty", "preparation", "presentation", "pressure", "privacy", "procedure", "process", "production", "profession", "progress", "promotion", "proposal", "protection", "psychology", "publication", "reaction", "reality", "recommendation", "reduction", "reflection", "refrigerator", "refusal", "relationship", "relaxation", "religion", "reputation", "research", "responsibility", "restriction", "satisfaction", "schedule", "scientific", "selection", "sensible", "separation", "significance", "solution", "spontaneous", "successful", "suggestion", "support", "technology", "temporary", "tendency", "theory", "tradition", "transportation", "understanding", "unemployment", "unexpected", "unfortunately", "universal", "university", "unusual", "valuable", "variety", "violence", "voluntary", "weakness", "willingness", "wisdom", "wonderful", "worthwhile"];
        const WORDS_B2 = ["ability", "achievement", "acquaintance", "adolescence", "allegation", "ambiguous", "analysis", "announcement", "anonymous", "anxiety", "apologize", "apparently", "application", "appointment", "appreciation", "appropriate", "architecture", "argument", "assistance", "association", "assumption", "atmosphere", "attendance", "availability", "awareness", "behaviour", "bureaucracy", "cancellation", "campaign", "capability", "characteristic", "coincidence", "commitment", "communication", "compensation", "competition", "complaint", "complicated", "comprehension", "concentration", "consequence", "consideration", "consistency", "construction", "contribution", "controversy", "corporation", "creativity", "criticism", "curiosity", "deception", "dedication", "definitely", "democracy", "demonstration", "development", "disappointment", "discussion", "dissatisfaction", "distinction", "diversity", "efficiency", "embarrassment", "emotion", "emphasis", "employment", "enthusiasm", "environment", "essential", "establishment", "exaggerate", "examination", "excitement", "existence", "explanation", "exploitation", "familiarity", "flexibility", "foundation", "frustration", "fundamentally", "government", "guarantee", "hospitality", "hypothesis", "identification", "imagination", "immediately", "impression", "inappropriate", "improvement", "independence", "individual", "inevitable", "influence", "information", "initiative", "innovation", "inspiration", "intelligence", "interaction", "interpretation", "introduction", "investigation", "involvement", "irresponsible", "justification", "knowledgeable", "leadership", "legislation", "limitation", "location", "management", "manipulation", "meaningful", "mechanism", "membership", "methodology", "motivation", "negotiation", "obligation", "opportunity", "organization", "paradox", "participant", "partnership", "perception", "performance", "permission", "personality", "phenomenon", "philosophy", "possibility", "prejudice", "preparation", "presentation", "preservation", "priority", "procedure", "profession", "professional", "psychology", "publication", "qualification", "realization", "recognize", "recommendation", "reduction", "reflection", "regulation", "relationship", "reliable", "reputation", "research", "responsibility", "restriction", "satisfaction", "schedule", "scientific", "secretary", "significant", "sophisticated", "spontaneous", "statement", "strategic", "substance", "suggestion", "superstition", "sustainability", "sympathetic", "technology", "temporary", "tendency", "theoretical", "tradition", "transformation", "unfortunately", "unforgettable", "universal", "unpredictable", "unreasonable", "unwillingness", "variation", "victim", "volunteering", "vulnerability", "weakness", "willingness", "wisdom", "withdrawal", "wonderful", "worthwhile", "abandonment", "accomplishment", "acknowledgment", "confrontation", "considerably", "controversial", "coordination", "credibility", "destination", "determination", "dissatisfaction", "distinction", "domination", "emergence", "enforcement", "enthusiastic", "evolutionary", "expectation", "explanation", "exploitation", "flexibility", "fluctuation", "frustration", "fundamental", "guarantee", "implementation", "inconvenience", "incorporation", "independently", "infrastructure", "inspirational", "institution", "insufficient", "intelligent", "intercultural", "interpretation", "investigation", "irresponsible", "justification", "knowledgeable", "limitation", "literature", "manipulation", "methodology", "misconception", "motivation", "negotiation", "obligation", "participation", "perception", "persistence", "personally", "phenomenon", "philosophy", "possibility", "preparation", "preoccupation", "presentation", "professionalism", "psychological", "publication", "qualification", "rationality", "realization", "recollection", "recommendation", "responsibility", "satisfaction", "significance", "sophistication", "spontaneous", "strategic", "substantially", "sustainability", "sympathy", "technology", "transformation", "uncertainty", "unconventional", "underestimated", "unpredictable", "unrealistic", "unwillingness", "vulnerability", "withdrawal", "worthwhile"];
        const WORD_LEVELS = ['A1', 'A2', 'B1', 'B2'];

        let gameState = {
            players: [], // Active players in the current round
            roundWinners: [],
            initialPlayers: [],
            playerCount: 0,
            allPlayers: [], // All players from the start
            currentDuel: {
                players: [],
                word1: '',
                word2: '',
                history: [],
                turn: 0
            },
            duelHistory: [],
            roundNumber: 1,
            nextMatchupIndex: 0,
            currentWordLevelIndex: 0,
            maxWordLevelIndex: 0,
            wordsUsed: new Set(), // This set now persists for the entire game
            stopwatch: null,
            stopwatchStarted: false,
            backspaceCount: 0,
            startTime: 0,
            isThirdPlaceDuel: false,
            semifinalLosers: [],
            thirdPlaceWinner: null,
            semifinalWinners: [],
            champion: null,
            finalLoser: null,
            // NEW: Qualifying round state
            gameMode: 'start', // 'qualifying', 'bracket', 'champion'
            qualifyingPlayers: [],
            qualifyingResults: [],
            qualifyingWord: '',
            qualifyingCurrentPlayerIndex: 0,
            qualifyingWordIndex: 0, // 0 for first word, 1 for second word
            qualifyingFirstWordResult: null
        };

        const elements = {
            startScreen: document.getElementById('start-screen'),
            gameAndBrackets: document.getElementById('game-and-brackets'),
            gameScreen: document.getElementById('game-screen'),
            championScreen: document.getElementById('champion-screen'),
            playerCountInput: document.getElementById('player-count'),
            maxDifficultyInput: document.getElementById('max-difficulty'),
            playerInputsContainer: document.getElementById('player-inputs'),
            startButton: document.getElementById('start-button'),
            roundTitle: document.getElementById('round-title'),
            duelSection: document.getElementById('duel-section'),
            player1Name: document.getElementById('player1-name'),
            player2Name: document.getElementById('player2-name'),
            player1Card: document.getElementById('player1-card'),
            player2Card: document.getElementById('player2-card'),
            currentPlayerTurn: document.getElementById('current-player-turn'),
            wordLevelDisplay: document.getElementById('word-level'),
            mcWord: document.getElementById('mc-word'),
            toggleWordButton: document.getElementById('toggle-word-button'),
            spellingInput: document.getElementById('spelling-input'),
            stopwatchDisplay: document.getElementById('stopwatch'),
            backspaceCountDisplay: document.getElementById('backspace-count'),
            submitButton: document.getElementById('submit-button'),
            resultsSection: document.getElementById('results-section'),
            resultsContent: document.getElementById('results-content'),
            nextDuelButton: document.getElementById('next-duel-button'),
            championName: document.getElementById('champion-name'),
            silverMedalName: document.getElementById('silver-medal'),
            bronzeMedalName: document.getElementById('bronze-medal'),
            playAgainButton: document.getElementById('play-again-button'),
            tournamentLog: document.getElementById('tournament-log'),
            tournamentContent: document.getElementById('tournament-content'),
            toggleTournamentLogButton: document.getElementById('toggle-tournament-log-button'),
            bracketView: document.getElementById('bracket-view'),
            bracketContainer: document.getElementById('bracket-container'),
            // NEW elements for qualifying round
            qualifyingSection: document.getElementById('qualifying-section'),
            qualifyingPlayerName: document.getElementById('qualifying-player-name'),
            qualifyingWordLevel: document.getElementById('qualifying-word-level'),
            qualifyingMcWord: document.getElementById('qualifying-mc-word'),
            qualifyingToggleWordButton: document.getElementById('qualifying-toggle-word-button'),
            qualifyingSpellingInput: document.getElementById('qualifying-spelling-input'),
            qualifyingStopwatch: document.getElementById('qualifying-stopwatch'),
            qualifyingBackspaceCount: document.getElementById('qualifying-backspace-count'),
            qualifyingSubmitButton: document.getElementById('qualifying-submit-button'),
            qualifyingResultsSection: document.getElementById('qualifying-results-section'),
            qualifyingResultsContent: document.getElementById('qualifying-results-content'),
            startBracketButton: document.getElementById('start-bracket-button'),
            qualifyingScoreboard: document.getElementById('qualifying-scoreboard'),
            qualifyingList: document.getElementById('qualifying-list')
        };
        
        // Tone.js sound setup
        // The correct sound is a simple high-pitched synth tone
        const correctSynth = new Tone.Synth({
            oscillator: { type: "sine" },
            envelope: { attack: 0.005, decay: 0.1, sustain: 0.01, release: 0.2 }
        }).toDestination();

        // The incorrect sound is a low, discordant tone
        const incorrectSynth = new Tone.Synth({
            oscillator: { type: "triangle" },
            envelope: { attack: 0.005, decay: 0.1, sustain: 0.01, release: 0.2 }
        }).toDestination();
        
        const playCorrectSound = () => correctSynth.triggerAttackRelease("C5", "8n");
        const playIncorrectSound = () => incorrectSynth.triggerAttackRelease("C3", "8n");

        const WORD_MAP = {
            'A1': WORDS_A1,
            'A2': WORDS_A2,
            'B1': WORDS_B1,
            'B2': WORDS_B2
        };

        // --- Utility Functions ---
        
        // Calculates the Levenshtein distance between two strings.
        // This is a more robust way to measure spelling accuracy.
        function calculateLevenshteinDistance(s1, s2) {
            s1 = s1.toLowerCase();
            s2 = s2.toLowerCase();
            const m = s1.length;
            const n = s2.length;
            const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(null));

            for (let i = 0; i <= m; i++) {
                dp[i][0] = i;
            }
            for (let j = 0; j <= n; j++) {
                dp[0][j] = j;
            }

            for (let i = 1; i <= m; i++) {
                for (let j = 1; j <= n; j++) {
                    const cost = s1[i - 1] === s2[j - 1] ? 0 : 1;
                    dp[i][j] = Math.min(
                        dp[i - 1][j] + 1,        // Deletion
                        dp[i][j - 1] + 1,        // Insertion
                        dp[i - 1][j - 1] + cost  // Substitution
                    );
                }
            }
            return dp[m][n];
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function formatTime(ms) {
            const minutes = Math.floor(ms / 60000);
            const seconds = Math.floor((ms % 60000) / 1000);
            const milliseconds = ms % 1000;
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}:${String(milliseconds).padStart(3, '0')}`;
        }

        function getNextPowerOfTwo(n) {
            if (n <= 2) return 2;
            let p = 2;
            while (p < n) {
                p *= 2;
            }
            return p;
        }

        function getPreviousPowerOfTwo(n) {
            if (n === 2) return 2;
            let p = 2;
            while (p * 2 <= n) {
                p *= 2;
            }
            return p;
        }

        // --- UI Rendering Functions ---
        function renderPlayerInputs() {
            const count = parseInt(elements.playerCountInput.value);
            elements.playerInputsContainer.innerHTML = '';
            for (let i = 0; i < count; i++) {
                const input = document.createElement('input');
                input.type = 'text';
                input.placeholder = `Player ${i + 1} Name`;
                input.value = `Player ${i + 1}`;
                input.className = 'w-full p-2 rounded-lg bg-[#0d1117] text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-neon-blue';
                input.id = `player-name-${i}`;
                elements.playerInputsContainer.appendChild(input);
            }
        }

        function updatePlayerCards() {
            const [player1, player2] = gameState.currentDuel.players;
            if (!player1 || !player2) {
                 console.error("Attempted to update player cards with undefined players.");
                 return;
            }
            elements.player1Name.textContent = player1.name;
            elements.player2Name.textContent = player2.name;

            elements.player1Card.classList.remove('active', 'winner');
            elements.player2Card.classList.remove('active', 'winner');

            if (gameState.currentDuel.turn === 0) {
                elements.player1Card.classList.add('active');
            } else if (gameState.currentDuel.turn === 1) {
                elements.player2Card.classList.add('active');
            }
        }
        
        function updateTournamentLog() {
            elements.tournamentContent.innerHTML = '';
            if (gameState.duelHistory.length === 0) {
                 elements.tournamentContent.innerHTML = '<p class="text-gray-500 text-center">No duels have been completed yet.</p>';
                 return;
            }
            gameState.duelHistory.forEach((duel, index) => {
                const winnerName = duel.players.find(p => p && p.id === duel.winner).name;
                const loserName = duel.players.find(p => p && p.id !== duel.winner).name;
                
                const historyItem = document.createElement('div');
                historyItem.className = `p-4 rounded-lg bg-[#161b22] shadow-md`;
                historyItem.innerHTML = `
                    <p class="text-lg font-bold">Duel ${index + 1}:</p>
                    <p><span class="text-green-400">${winnerName}</span> defeated <span class="text-red-400">${loserName}</span></p>
                `;
                elements.tournamentContent.appendChild(historyItem);
            });
        }

        function renderBrackets() {
            elements.bracketContainer.innerHTML = '';
            let currentPlayers = [...gameState.initialPlayers];
            let rounds = [];
            
            const totalRounds = Math.log2(gameState.initialPlayers.length);

            // Determine rounds
            while (currentPlayers.length > 1) {
                const round = [];
                const nextRoundPlayers = [];
                for (let i = 0; i < currentPlayers.length; i += 2) {
                    const player1 = currentPlayers[i];
                    const player2 = currentPlayers[i + 1];
                    let winner = null;
                    let loser = null;

                    const duel = gameState.duelHistory.find(d => 
                        (d.players.find(p => p.id === player1.id) && d.players.find(p => p.id === player2.id))
                    );

                    if (duel) {
                        winner = gameState.allPlayers.find(p => p.id === duel.winner);
                        loser = gameState.allPlayers.find(p => p.id !== duel.winner && duel.players.some(dp => dp.id === p.id));
                    }

                    round.push({ player1, player2, winner, loser });
                    nextRoundPlayers.push(winner || { id: null, name: 'TBD' });
                }
                rounds.push(round);
                currentPlayers = nextRoundPlayers;
            }

            // Render rounds
            rounds.forEach((roundData, roundIndex) => {
                const roundEl = document.createElement('div');
                roundEl.className = `round flex-shrink-0`;
                const roundTitle = document.createElement('h3');
                roundTitle.className = `text-lg font-bold text-center mb-4`;
                roundTitle.textContent = `Round ${roundIndex + 1}`;
                roundEl.appendChild(roundTitle);

                roundData.forEach(matchupData => {
                    const matchupEl = document.createElement('div');
                    matchupEl.className = `matchup`;

                    const player1El = document.createElement('div');
                    let p1Class = 'player-name';
                    if (matchupData.winner && matchupData.winner.id === matchupData.player1.id) p1Class += ' winner-player';
                    if (matchupData.loser && matchupData.loser.id === matchupData.player1.id) p1Class += ' loser-player';
                    player1El.className = p1Class;
                    player1El.textContent = matchupData.player1 ? matchupData.player1.name : 'TBD';
                    matchupEl.appendChild(player1El);

                    const player2El = document.createElement('div');
                    let p2Class = 'player-name';
                    if (matchupData.winner && matchupData.winner.id === matchupData.player2.id) p2Class += ' winner-player';
                    if (matchupData.loser && matchupData.loser.id === matchupData.player2.id) p2Class += ' loser-player';
                    player2El.className = p2Class;
                    player2El.textContent = matchupData.player2 ? matchupData.player2.name : 'TBD';
                    matchupEl.appendChild(player2El);

                    roundEl.appendChild(matchupEl);
                });
                elements.bracketContainer.appendChild(roundEl);
            });

            if (gameState.players.length === 1 && gameState.duelHistory.length > 0) {
                const champion = gameState.players[0];
                const finalRoundEl = document.createElement('div');
                finalRoundEl.className = `round flex-shrink-0`;
                const finalTitle = document.createElement('h3');
                finalTitle.className = `text-lg font-bold text-center mb-4`;
                finalTitle.textContent = `Champion`;
                finalRoundEl.appendChild(finalTitle);

                const winnerEl = document.createElement('div');
                winnerEl.className = `matchup`;
                const winnerNameEl = document.createElement('div');
                winnerNameEl.className = `player-name winner-player`;
                winnerNameEl.textContent = champion.name;
                winnerEl.appendChild(winnerNameEl);
                finalRoundEl.appendChild(winnerEl);
                elements.bracketContainer.appendChild(finalRoundEl);
            }
        }

        function updateQualifyingScoreboard() {
            elements.qualifyingList.innerHTML = '';
            
            // Sort players by score, then time, then backspaces
            const sortedPlayers = [...gameState.qualifyingResults].sort((a, b) => {
                if (b.score !== a.score) {
                    return b.score - a.score;
                }
                if (a.time !== b.time) {
                    return a.time - b.time;
                }
                return a.backspace - b.backspace;
            });
            
            sortedPlayers.forEach(playerResult => {
                const listItem = document.createElement('li');
                listItem.className = 'p-4 rounded-lg bg-[#0d1117] flex justify-between items-center';
                listItem.innerHTML = `
                    <div class="font-semibold text-lg">${playerResult.player.name}</div>
                    <div class="text-right">
                        <p>Score: ${playerResult.score}</p>
                        <p class="text-sm text-gray-400">Time: ${formatTime(playerResult.time)} | Backspaces: ${playerResult.backspace}</p>
                    </div>
                `;
                elements.qualifyingList.appendChild(listItem);
            });
        }

        // --- Game Logic Functions ---
        function setupGame() {
            const playerCount = parseInt(elements.playerCountInput.value);
            gameState.playerCount = playerCount;
            gameState.players = [];
            gameState.roundWinners = [];
            gameState.allPlayers = [];
            gameState.semifinalLosers = [];
            gameState.isThirdPlaceDuel = false;
            gameState.thirdPlaceWinner = null;
            gameState.semifinalWinners = [];
            gameState.champion = null;
            gameState.finalLoser = null;
            gameState.qualifyingResults = [];
            
            gameState.maxWordLevelIndex = WORD_LEVELS.indexOf(elements.maxDifficultyInput.value);
            
            for (let i = 0; i < playerCount; i++) {
                const name = document.getElementById(`player-name-${i}`).value || `Player ${i + 1}`;
                const player = { id: `player-${i}`, name: name, isWinner: false, score: 0, time: 0, backspace: 0 };
                gameState.allPlayers.push(player);
                gameState.players.push(player);
            }

            shuffleArray(gameState.players);
            
            const isPowerOfTwo = (playerCount & (playerCount - 1)) === 0 && playerCount > 0;
            if (isPowerOfTwo) {
                gameState.gameMode = 'bracket';
                gameState.initialPlayers = [...gameState.players];
                startGame();
            } else {
                gameState.gameMode = 'qualifying';
                startQualifyingRound();
            }
        }

        function startGame() {
            elements.startScreen.classList.add('hidden');
            elements.gameAndBrackets.classList.remove('hidden');
            elements.resultsSection.classList.add('hidden');
            elements.tournamentLog.classList.add('hidden');
            
            gameState.roundNumber = 1;
            gameState.nextMatchupIndex = 0;
            gameState.currentWordLevelIndex = 0;
            gameState.wordsUsed.clear(); 
            gameState.duelHistory = [];
            
            gameState.allPlayers.forEach(player => player.isWinner = false);
            
            elements.roundTitle.textContent = `Round 1`;
            renderBrackets();
            startNextDuel();
        }

        // --- Qualifying Round Logic ---
        function startQualifyingRound() {
            gameState.gameMode = 'qualifying';
            elements.startScreen.classList.add('hidden');
            elements.gameAndBrackets.classList.remove('hidden');
            elements.duelSection.classList.add('hidden');
            elements.resultsSection.classList.add('hidden');
            elements.qualifyingSection.classList.remove('hidden');
            elements.qualifyingResultsSection.classList.add('hidden');
            elements.tournamentLog.classList.add('hidden');

            elements.roundTitle.textContent = `Qualifying Round`;
            gameState.qualifyingPlayers = [...gameState.players];
            gameState.qualifyingCurrentPlayerIndex = 0;
            gameState.qualifyingWordIndex = 0;
            gameState.qualifyingFirstWordResult = null;
            gameState.wordsUsed.clear(); 
            
            nextQualifyingTurn();
        }

        function nextQualifyingTurn() {
            if (gameState.qualifyingCurrentPlayerIndex >= gameState.qualifyingPlayers.length) {
                endQualifyingRound();
                return;
            }

            const currentPlayer = gameState.qualifyingPlayers[gameState.qualifyingCurrentPlayerIndex];
            
            let wordLevel;
            let wordNumber;
            
            if (gameState.qualifyingWordIndex === 0) {
                 wordLevel = WORD_LEVELS[gameState.maxWordLevelIndex];
                 wordNumber = "1 of 2";
            } else {
                 const lowerLevelIndex = Math.max(0, gameState.maxWordLevelIndex - 1);
                 wordLevel = WORD_LEVELS[lowerLevelIndex];
                 wordNumber = "2 of 2";
            }
            
            // Get a word and make sure it hasn't been used
            let wordsForLevel = WORD_MAP[wordLevel];
            let word = wordsForLevel[Math.floor(Math.random() * wordsForLevel.length)];
            while(gameState.wordsUsed.has(word)) {
                word = wordsForLevel[Math.floor(Math.random() * wordsForLevel.length)];
            }
            gameState.wordsUsed.add(word);
            gameState.qualifyingWord = word.toLowerCase();
            
            elements.qualifyingPlayerName.textContent = `It's ${currentPlayer.name}'s turn! (Word ${wordNumber})`;
            elements.qualifyingWordLevel.textContent = `Word Level: ${wordLevel}`;
            elements.qualifyingMcWord.textContent = gameState.qualifyingWord;
            elements.qualifyingMcWord.classList.add('hidden');
            elements.qualifyingToggleWordButton.textContent = 'Show Word';
            elements.qualifyingSpellingInput.value = '';
            elements.qualifyingSpellingInput.focus();

            clearInterval(gameState.stopwatch);
            gameState.stopwatchStarted = false;
            gameState.backspaceCount = 0;
            gameState.startTime = 0;
            elements.qualifyingStopwatch.textContent = '00:00:00';
            elements.qualifyingBackspaceCount.textContent = '0';
            elements.qualifyingSpellingInput.disabled = false;
            elements.qualifyingSubmitButton.disabled = false;
        }

        function calculateWordScore(submittedWord, correctWord, spellingTime, backspace) {
            const levenshteinDistance = calculateLevenshteinDistance(submittedWord, correctWord);
            
            // This is a simple scoring system. Lower Levenshtein distance is better.
            let score = correctWord.length - levenshteinDistance;
            
            // Bonus for correct word
            if (levenshteinDistance === 0) {
                 score += 1000;
            }

            // Penalties
            score -= (backspace * 10);
            score -= Math.floor(spellingTime / 100);

            return score;
        }

        function submitQualifyingSpelling() {
            const submittedWord = elements.qualifyingSpellingInput.value.toLowerCase();
            if (submittedWord.trim() === '') return;

            const spellingTime = Date.now() - gameState.startTime;
            clearInterval(gameState.stopwatch);
            
            const currentPlayer = gameState.qualifyingPlayers[gameState.qualifyingCurrentPlayerIndex];
            const correctWord = gameState.qualifyingWord;
            
            const currentScore = calculateWordScore(submittedWord, correctWord, spellingTime, gameState.backspaceCount);

            if (gameState.qualifyingWordIndex === 0) {
                 // First word submitted, save result and proceed to second word
                 gameState.qualifyingFirstWordResult = {
                    player: currentPlayer,
                    score: currentScore,
                    submitted: submittedWord,
                    isCorrect: submittedWord === correctWord,
                    backspace: gameState.backspaceCount,
                    time: spellingTime,
                    levenshtein: calculateLevenshteinDistance(submittedWord, correctWord)
                 };
                 gameState.qualifyingWordIndex = 1;
                 
                 // Play sound based on correctness
                 if (gameState.qualifyingFirstWordResult.isCorrect) {
                     playCorrectSound();
                 } else {
                     playIncorrectSound();
                 }
                 
                 nextQualifyingTurn();
            } else {
                 // Second word submitted, combine scores and advance player
                 const totalScore = gameState.qualifyingFirstWordResult.score + currentScore;
                 const totalTime = gameState.qualifyingFirstWordResult.time + spellingTime;
                 const totalBackspaces = gameState.qualifyingFirstWordResult.backspace + gameState.backspaceCount;

                 gameState.qualifyingResults.push({
                    player: currentPlayer,
                    score: totalScore,
                    time: totalTime,
                    backspace: totalBackspaces,
                    results: [
                        gameState.qualifyingFirstWordResult,
                        {
                            submitted: submittedWord,
                            isCorrect: submittedWord === correctWord,
                            backspace: gameState.backspaceCount,
                            time: spellingTime,
                            levenshtein: calculateLevenshteinDistance(submittedWord, correctWord)
                        }
                    ]
                 });
                 
                 // Play sound based on correctness
                 if (submittedWord === correctWord) {
                     playCorrectSound();
                 } else {
                     playIncorrectSound();
                 }

                 gameState.qualifyingWordIndex = 0;
                 gameState.qualifyingFirstWordResult = null;
                 gameState.qualifyingCurrentPlayerIndex++;
                 updateQualifyingScoreboard();
                 nextQualifyingTurn();
            }
        }

        function endQualifyingRound() {
            elements.qualifyingSection.classList.add('hidden');
            elements.qualifyingResultsSection.classList.remove('hidden');

            const sortedPlayers = [...gameState.qualifyingResults].sort((a, b) => {
                if (b.score !== a.score) {
                    return b.score - a.score;
                }
                if (a.time !== b.time) {
                    return a.time - b.time;
                }
                return a.backspace - b.backspace;
            });
            
            const numToAdvance = getPreviousPowerOfTwo(gameState.playerCount);
            const advancingPlayers = sortedPlayers.slice(0, numToAdvance).map(res => res.player);
            const eliminatedPlayers = sortedPlayers.slice(numToAdvance);

            let html = `<p class="text-xl font-semibold mb-4 text-green-400">The top ${numToAdvance} players advance to the main bracket!</p>`;
            html += `<h4 class="text-lg font-bold mt-4 mb-2">Advancing Players:</h4>`;
            html += `<ul class="list-disc list-inside space-y-1 mb-4 text-left mx-auto max-w-sm">`;
            advancingPlayers.forEach(p => html += `<li>${p.name}</li>`);
            html += `</ul>`;
            
            if (eliminatedPlayers.length > 0) {
                 html += `<h4 class="text-lg font-bold mt-4 mb-2 text-red-400">Eliminated Players:</h4>`;
                 html += `<ul class="list-disc list-inside space-y-1 mb-4 text-left mx-auto max-w-sm">`;
                 eliminatedPlayers.forEach(p => html += `<li>${p.player.name}</li>`);
                 html += `</ul>`;
            }

            elements.qualifyingResultsContent.innerHTML = html;

            gameState.players = advancingPlayers;
            gameState.initialPlayers = [...advancingPlayers];
            gameState.gameMode = 'bracket';
        }

        // --- Bracket Logic ---
        function startNextDuel() {
            if (gameState.nextMatchupIndex >= gameState.players.length) {
                advanceRound();
                return;
            }
            
            const player1 = gameState.players[gameState.nextMatchupIndex];
            const player2 = gameState.players[gameState.nextMatchupIndex + 1];

            // Select a random word for the first player to determine length
            let wordsForLevel = WORD_MAP[WORD_LEVELS[gameState.currentWordLevelIndex]];
            let word1 = wordsForLevel[Math.floor(Math.random() * wordsForLevel.length)];
            while(gameState.wordsUsed.has(word1)) {
                word1 = wordsForLevel[Math.floor(Math.random() * wordsForLevel.length)];
            }
            gameState.wordsUsed.add(word1);
            
            // Now, find a second word of the same length
            let wordsOfSameLength = wordsForLevel.filter(word => word.length === word1.length && !gameState.wordsUsed.has(word));
            
            let word2;
            if (wordsOfSameLength.length > 0) {
                word2 = wordsOfSameLength[Math.floor(Math.random() * wordsOfSameLength.length)];
                gameState.wordsUsed.add(word2);
            } else {
                // Fallback if no other word of the same length exists
                word2 = word1;
            }

            gameState.currentDuel = {
                players: [player1, player2],
                word1: word1.toLowerCase(),
                word2: word2.toLowerCase(),
                history: [],
                turn: 0
            };
            
            elements.duelSection.classList.remove('hidden');
            elements.resultsSection.classList.add('hidden');
            elements.nextDuelButton.classList.remove('hidden');
            elements.nextDuelButton.textContent = 'Next Duel';
            
            updatePlayerCards();
            elements.currentPlayerTurn.textContent = `It's ${player1.name}'s turn!`;
            
            elements.spellingInput.value = '';
            
            clearInterval(gameState.stopwatch);
            gameState.stopwatchStarted = false;
            gameState.backspaceCount = 0;
            gameState.startTime = 0;
            elements.stopwatchDisplay.textContent = '00:00:00';
            elements.backspaceCountDisplay.textContent = '0';
            elements.spellingInput.disabled = false;
            elements.submitButton.disabled = false;
            elements.spellingInput.focus();

            elements.wordLevelDisplay.textContent = `Word Level: ${WORD_LEVELS[gameState.currentWordLevelIndex]}`;
            elements.mcWord.textContent = gameState.currentDuel.word1;
            elements.mcWord.classList.add('hidden');
            elements.toggleWordButton.textContent = 'Show Word';
        }

        function checkSpelling() {
            const submittedWord = elements.spellingInput.value.toLowerCase();
            if (submittedWord.trim() === '') {
                return;
            }
            
            clearInterval(gameState.stopwatch);
            
            const spellingTime = Date.now() - gameState.startTime;
            
            const currentPlayer = gameState.currentDuel.players[gameState.currentDuel.turn];
            const correctWord = gameState.currentDuel.turn === 0 ? gameState.currentDuel.word1 : gameState.currentDuel.word2;

            const backspace = gameState.backspaceCount;
            const levenshteinDistance = calculateLevenshteinDistance(submittedWord, correctWord);
            const isCorrect = levenshteinDistance === 0;

            const result = {
                player: currentPlayer.name,
                submitted: submittedWord,
                isCorrect: isCorrect,
                levenshtein: levenshteinDistance,
                backspace: backspace,
                time: spellingTime,
                correctWord: correctWord
            };
            
            // Play sound based on correctness
            if (isCorrect) {
                playCorrectSound();
            } else {
                playIncorrectSound();
            }
            
            gameState.currentDuel.history.push(result);

            if (gameState.currentDuel.turn === 0) {
                gameState.currentDuel.turn = 1;
                updatePlayerCards();
                elements.spellingInput.value = '';
                elements.spellingInput.focus();
                
                elements.currentPlayerTurn.textContent = `Get ready, ${gameState.currentDuel.players[1].name}!`;
                
                elements.mcWord.textContent = gameState.currentDuel.word2;

                clearInterval(gameState.stopwatch);
                gameState.stopwatchStarted = false;
                gameState.backspaceCount = 0;
                gameState.startTime = 0;
                elements.stopwatchDisplay.textContent = '00:00:00';
                elements.backspaceCountDisplay.textContent = '0';
                elements.mcWord.classList.add('hidden');
                elements.toggleWordButton.textContent = 'Show Word';
            } else {
                showDuelResults();
            }
        }

        function showDuelResults() {
            elements.duelSection.classList.add('hidden');
            elements.resultsSection.classList.remove('hidden');
            elements.nextDuelButton.classList.remove('hidden');

            const [result1, result2] = gameState.currentDuel.history;
            const [player1, player2] = gameState.currentDuel.players;

            let winner = null;
            let loser = null;
            let tiebreakReason = '';
            
            const p1IsCorrect = result1.isCorrect;
            const p2IsCorrect = result2.isCorrect;

            // Handle the tie-breaker logic
            if (p1IsCorrect && !p2IsCorrect) {
                // Player 1 correct, Player 2 incorrect
                winner = player1;
                loser = player2;
            } else if (!p1IsCorrect && p2IsCorrect) {
                // Player 2 correct, Player 1 incorrect
                winner = player2;
                loser = player1;
            } else if (p1IsCorrect && p2IsCorrect) {
                // Both are correct
                if (result1.backspace !== result2.backspace) {
                    // Tie-breaker 1: Fewer backspaces wins
                    winner = result1.backspace < result2.backspace ? player1 : player2;
                    loser = winner === player1 ? player2 : player1;
                    tiebreakReason = 'Winner by fewer backspaces!';
                } else if (Math.abs(result1.time - result2.time) >= 10000) {
                    // Tie-breaker 2: 10-second minimum time difference
                    winner = result1.time < result2.time ? player1 : player2;
                    loser = winner === player1 ? player2 : player1;
                    tiebreakReason = `Winner by faster time (${formatTime(Math.abs(result1.time - result2.time))} difference)!`;
                } else if (gameState.currentWordLevelIndex < gameState.maxWordLevelIndex) {
                    // Tie-breaker 3: Advance to next higher difficulty word
                    gameState.currentWordLevelIndex++;
                    
                    // Same-length word logic for the tie-breaker round
                    const wordsForLevel = WORD_MAP[WORD_LEVELS[gameState.currentWordLevelIndex]];
                    let newWord1 = wordsForLevel.find(w => !gameState.wordsUsed.has(w));
                    if (!newWord1) newWord1 = wordsForLevel[0];
                    gameState.wordsUsed.add(newWord1);
                    
                    const wordsOfSameLength = wordsForLevel.filter(word => word.length === newWord1.length && !gameState.wordsUsed.has(word));
                    let newWord2;
                    if (wordsOfSameLength.length > 0) {
                        newWord2 = wordsOfSameLength[Math.floor(Math.random() * wordsOfSameLength.length)];
                        gameState.wordsUsed.add(newWord2);
                    } else {
                        newWord2 = newWord1;
                    }
                    
                    gameState.currentDuel.word1 = newWord1.toLowerCase();
                    gameState.currentDuel.word2 = newWord2.toLowerCase();
                    gameState.currentDuel.turn = 0;
                    gameState.currentDuel.history = [];
                    
                    elements.duelSection.classList.remove('hidden');
                    elements.resultsSection.classList.add('hidden');
                    updatePlayerCards();
                    elements.currentPlayerTurn.textContent = `It's a tie! New word: It's ${player1.name}'s turn!`;
                    elements.wordLevelDisplay.textContent = `Word Level: ${WORD_LEVELS[gameState.currentWordLevelIndex]}`;
                    elements.mcWord.textContent = newWord1;
                    elements.spellingInput.value = '';
                    elements.spellingInput.focus();
                    
                    clearInterval(gameState.stopwatch);
                    gameState.stopwatchStarted = false;
                    gameState.backspaceCount = 0;
                    gameState.startTime = 0;
                    elements.stopwatchDisplay.textContent = '00:00:00';
                    elements.backspaceCountDisplay.textContent = '0';
                    elements.mcWord.classList.add('hidden');
                    elements.toggleWordButton.textContent = 'Show Word';
                    return; // Exit the function to start the new round
                } else {
                    // Final Tie-breaker: Same difficulty, fastest time wins
                    winner = result1.time < result2.time ? player1 : player2;
                    loser = winner === player1 ? player2 : player1;
                    tiebreakReason = 'Winner by fastest time!';
                }
            } else {
                // Both are incorrect
                if (result1.levenshtein !== result2.levenshtein) {
                    // Tie-breaker 1: Lower Levenshtein distance wins
                    winner = result1.levenshtein < result2.levenshtein ? player1 : player2;
                    loser = winner === player1 ? player2 : player1;
                    tiebreakReason = 'Winner by better accuracy (lower Levenshtein distance)!';
                } else if (result1.backspace !== result2.backspace) {
                    // Tie-breaker 2: Fewer backspaces wins
                    winner = result1.backspace < result2.backspace ? player1 : player2;
                    loser = winner === player1 ? player2 : player1;
                    tiebreakReason = 'Winner by fewer backspaces!';
                } else {
                    // Tie-breaker 3: Faster time wins
                    winner = result1.time < result2.time ? player1 : player2;
                    loser = winner === player1 ? player2 : player1;
                    tiebreakReason = 'Winner by faster time!';
                }
            }
            
            gameState.roundWinners.push(winner);
            
            if (gameState.players.length === 4) {
                 gameState.semifinalLosers.push(loser);
            }

            if (gameState.players.length === 2 && !gameState.isThirdPlaceDuel) {
                gameState.finalLoser = loser;
                elements.nextDuelButton.textContent = 'Final Results';
            }

            gameState.duelHistory.push({
                players: gameState.currentDuel.players,
                winner: winner.id,
                loser: loser.id,
                duelHistory: gameState.currentDuel.history
            });

            const winnerInAllPlayers = gameState.allPlayers.find(p => p && p.id === winner.id);
            if (winnerInAllPlayers) {
                winnerInAllPlayers.isWinner = true;
            }

            elements.player1Card.classList.remove('active');
            elements.player2Card.classList.remove('active');
            if (winner === player1) {
                elements.player1Card.classList.add('winner');
            } else {
                elements.player2Card.classList.add('winner');
            }

            let html = `<h3 class="text-3xl font-bold text-center mt-6 mb-4 text-neon-blue">${winner.name} Wins!</h3>`;
            if (tiebreakReason) {
                html += `<p class="text-lg font-semibold text-center mb-4 text-gray-400">(${tiebreakReason})</p>`;
            }
            html += `<div class="space-y-4 text-left">`;

            gameState.currentDuel.history.forEach((history, index) => {
                html += `
                    <div class="p-4 rounded-lg bg-[#0d1117] flex justify-between items-start flex-wrap">
                        <div class="w-full text-center text-lg font-semibold mb-2">${history.player}'s turn</div>
                        <div class="w-full p-2">
                            <p class="${history.isCorrect ? 'text-green-500' : 'text-red-500'}">Submitted: "${history.submitted}"</p>
                            <p>Correct word: "${history.correctWord}"</p>
                            <p>Levenshtein Distance: ${history.levenshtein}</p>
                            <p>Backspaces: ${history.backspace}</p>
                            <p>Time: ${formatTime(history.time)}</p>
                        </div>
                    </div>
                `;
            });
            html += `</div>`;
            elements.resultsContent.innerHTML = html;
            updateTournamentLog();
            
            renderBrackets();
        }
        
        function continueTournament() {
             gameState.nextMatchupIndex += 2;
             
             if (gameState.nextMatchupIndex >= gameState.players.length) {
                 advanceRound();
             } else {
                 startNextDuel();
             }
        }

        function advanceRound() {
            if (gameState.players.length === 4 && gameState.roundWinners.length === 2 && !gameState.isThirdPlaceDuel) {
                gameState.semifinalWinners = [...gameState.roundWinners];
                
                gameState.players = [...gameState.semifinalLosers];
                gameState.roundWinners = [];
                gameState.isThirdPlaceDuel = true;
                gameState.nextMatchupIndex = 0;
                
                elements.roundTitle.textContent = '3rd Place Duel';
                startNextDuel();
                return;
            }

            if (gameState.isThirdPlaceDuel && gameState.roundWinners.length === 1) {
                gameState.thirdPlaceWinner = gameState.roundWinners[0];
                gameState.isThirdPlaceDuel = false;
                gameState.roundWinners = [];
                
                gameState.players = [...gameState.semifinalWinners];
                gameState.nextMatchupIndex = 0;
                elements.roundTitle.textContent = 'Finals';
                startNextDuel();
                return;
            }

            gameState.players = [...gameState.roundWinners];
            gameState.roundWinners = [];

            if (gameState.players.length === 1) {
                gameState.champion = gameState.players[0];
                showChampion();
                return;
            }

            gameState.roundNumber++;
            elements.roundTitle.textContent = `Round ${gameState.roundNumber}`;
            gameState.nextMatchupIndex = 0;
            
            if (gameState.currentWordLevelIndex < gameState.maxWordLevelIndex) {
                 gameState.currentWordLevelIndex++;
            }
            
            shuffleArray(gameState.players);
            startNextDuel();
        }


        function showChampion() {
            elements.gameAndBrackets.classList.add('hidden');
            elements.championScreen.classList.remove('hidden');
            
            elements.championName.textContent = gameState.champion.name;
            elements.silverMedalName.textContent = gameState.finalLoser.name;
            elements.bronzeMedalName.textContent = gameState.thirdPlaceWinner ? gameState.thirdPlaceWinner.name : 'Not applicable';
            
            const championInAllPlayers = gameState.allPlayers.find(p => p && p.id === gameState.champion.id);
            if (championInAllPlayers) {
                 championInAllPlayers.isWinner = true;
            }
        }

        function resetGame() {
            gameState.players = [];
            gameState.roundWinners = [];
            gameState.initialPlayers = [];
            gameState.playerCount = 0;
            gameState.allPlayers = [];
            gameState.currentDuel = { players: [], word1: '', word2: '', history: [], turn: 0 };
            gameState.duelHistory = [];
            gameState.roundNumber = 1;
            gameState.nextMatchupIndex = 0;
            gameState.currentWordLevelIndex = 0;
            gameState.maxWordLevelIndex = 0;
            gameState.wordsUsed.clear();
            gameState.semifinalLosers = [];
            gameState.isThirdPlaceDuel = false;
            gameState.thirdPlaceWinner = null;
            gameState.semifinalWinners = [];
            gameState.champion = null;
            gameState.finalLoser = null;
            gameState.gameMode = 'start';
            gameState.qualifyingPlayers = [];
            gameState.qualifyingResults = [];
            gameState.qualifyingWord = '';
            gameState.qualifyingCurrentPlayerIndex = 0;
            gameState.qualifyingWordIndex = 0;
            gameState.qualifyingFirstWordResult = null;

            elements.startScreen.classList.remove('hidden');
            elements.gameAndBrackets.classList.add('hidden');
            elements.championScreen.classList.add('hidden');
            elements.playerCountInput.value = 4;
            elements.maxDifficultyInput.value = 'A1';
            renderPlayerInputs();
        }
        
        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            renderPlayerInputs();
        });

        elements.playerCountInput.addEventListener('change', renderPlayerInputs);
        elements.startButton.addEventListener('click', setupGame);
        
        elements.spellingInput.addEventListener('keyup', (event) => {
            if (event.key === 'Enter') {
                checkSpelling();
            }
        });

        elements.qualifyingSpellingInput.addEventListener('keyup', (event) => {
            if (event.key === 'Enter') {
                submitQualifyingSpelling();
            }
        });

        elements.submitButton.addEventListener('click', checkSpelling);
        elements.qualifyingSubmitButton.addEventListener('click', submitQualifyingSpelling);
        elements.startBracketButton.addEventListener('click', startGame);

        elements.nextDuelButton.addEventListener('click', continueTournament);
        elements.playAgainButton.addEventListener('click', resetGame);
        
        elements.spellingInput.addEventListener('keydown', (event) => {
            if (!gameState.stopwatchStarted) {
                gameState.stopwatchStarted = true;
                gameState.startTime = Date.now();
                gameState.stopwatch = setInterval(() => {
                    const elapsed = Date.now() - gameState.startTime;
                    elements.stopwatchDisplay.textContent = formatTime(elapsed);
                }, 1);
            }
            if (event.key === 'Backspace' || event.key === 'Delete') {
                gameState.backspaceCount++;
                elements.backspaceCountDisplay.textContent = gameState.backspaceCount;
            }
        });

        elements.qualifyingSpellingInput.addEventListener('keydown', (event) => {
             if (!gameState.stopwatchStarted) {
                gameState.stopwatchStarted = true;
                gameState.startTime = Date.now();
                gameState.stopwatch = setInterval(() => {
                    const elapsed = Date.now() - gameState.startTime;
                    elements.qualifyingStopwatch.textContent = formatTime(elapsed);
                }, 1);
            }
            if (event.key === 'Backspace' || event.key === 'Delete') {
                gameState.backspaceCount++;
                elements.qualifyingBackspaceCount.textContent = gameState.backspaceCount;
            }
        });


        elements.toggleWordButton.addEventListener('click', () => {
            elements.mcWord.classList.toggle('hidden');
            if (elements.mcWord.classList.contains('hidden')) {
                elements.toggleWordButton.textContent = 'Show Word';
            } else {
                elements.toggleWordButton.textContent = 'Hide Word';
            }
        });
        
        elements.qualifyingToggleWordButton.addEventListener('click', () => {
            elements.qualifyingMcWord.classList.toggle('hidden');
            if (elements.qualifyingMcWord.classList.contains('hidden')) {
                elements.qualifyingToggleWordButton.textContent = 'Show Word';
            } else {
                elements.qualifyingToggleWordButton.textContent = 'Hide Word';
            }
        });

        elements.toggleTournamentLogButton.addEventListener('click', () => {
            elements.tournamentLog.classList.toggle('hidden');
            if (elements.tournamentLog.classList.contains('hidden')) {
                elements.toggleTournamentLogButton.textContent = 'Show Tournament Log';
            } else {
                elements.toggleTournamentLogButton.textContent = 'Hide Tournament Log';
            }
        });

    </script>
</body>
</html>
