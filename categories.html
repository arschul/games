<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Team Challenge Game</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <style>
    :root {
      --background-color: #f0f2f5;
      --text-color: #333;
      --primary-color: #4caf50; /* Green */
      --secondary-color: #f44336; /* Red */
      --accent-color: #2196f3; /* Blue */
      --card-background: #ffffff;
      --border-color: #ddd;
      --strike-color: #ffc107; /* Amber */
      --disabled-color: #ccc;
    }
    body.dark-mode {
      --background-color: #2c2c2c;
      --text-color: #e0e0e0;
      --primary-color: #66bb6a;
      --secondary-color: #ef5350;
      --accent-color: #42a5f5;
      --card-background: #3a3a3a;
      --border-color: #555;
      --strike-color: #ffeb3b;
      --disabled-color: #666;
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--background-color);
      color: var(--text-color);
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      transition: background-color 0.3s, color 0.3s;
    }
    main {
      background-color: var(--card-background);
      border-radius: 12px;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
      padding: 30px;
      width: 90%;
      max-width: 900px;
      text-align: center;
      display: flex;
      flex-direction: column;
      gap: 25px;
      position: relative;
    }
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    h1 {
      color: var(--accent-color);
      font-size: 2.5em;
      margin: 0;
    }
    .screen {
      display: none;
      flex-direction: column;
      gap: 20px;
      align-items: center;
    }
    .screen.active {
      display: flex;
    }
    h2 {
      color: var(--text-color);
      font-size: 2em;
      margin-bottom: 15px;
    }
    .form-group {
      margin-bottom: 15px;
      width: 100%;
      max-width: 400px;
      text-align: left;
    }
    .form-group input[type="text"],
    .form-group select {
      width: 100%;
      padding: 12px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      background-color: var(--background-color);
      color: var(--text-color);
      font-size: 1em;
      transition: border-color 0.3s, background-color 0.3s;
    }
    .form-group input[type="text"]:focus,
    .form-group select:focus {
      outline: none;
      border-color: var(--accent-color);
      box-shadow: 0 0 0 3px rgba(var(--accent-color-rgb, 33, 150, 243), 0.2);
    }
    .button {
      background-color: var(--primary-color);
      color: white;
      padding: 14px 25px;
      border: none;
      border-radius: 8px;
      font-size: 1.1em;
      cursor: pointer;
      transition: background-color 0.3s, transform 0.1s;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }
    .button:hover {
      background-color: var(--primary-color);
      filter: brightness(1.1);
      transform: translateY(-2px);
    }
    .button:active {
      transform: translateY(0);
    }
    .icon-button {
      background: none;
      border: none;
      cursor: pointer;
      color: var(--text-color);
      transition: color 0.3s, transform 0.1s;
      padding: 10px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .icon-button .material-icons {
      font-size: 28px;
    }
    .icon-button:hover {
      color: var(--accent-color);
      transform: scale(1.1);
    }
    #darkModeToggle {
      color: var(--text-color);
    }
    #darkModeToggle:hover {
      color: var(--accent-color);
    }
    /* Game Screen Styles */
    #teams-container {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 20px;
      margin-bottom: 30px;
    }
    .team-box {
      background-color: var(--card-background);
      border: 2px solid var(--border-color);
      border-radius: 10px;
      padding: 15px 20px;
      min-width: 180px;
      text-align: center;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
      transition: border-color 0.3s, box-shadow 0.3s, opacity 0.3s;
      position: relative;
    }
    .team-box.active {
      border-color: var(--accent-color);
      box-shadow: 0 0 0 4px rgba(var(--accent-color-rgb, 33, 150, 243), 0.3);
    }
    .team-box.out {
      opacity: 0.5;
      filter: grayscale(100%);
      pointer-events: none; /* Prevent interaction */
    }
    .team-name {
      font-size: 1.4em;
      font-weight: bold;
      margin-bottom: 10px;
      color: var(--text-color);
    }
    .strikes {
      display: flex;
      justify-content: center;
      gap: 5px;
      min-height: 24px; /* Ensure consistent height */
    }
    .strike-icon {
      color: var(--strike-color);
      font-size: 24px;
    }
    .game-area {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 25px;
    }
    .categories-display {
      display: flex;
      gap: 15px;
      margin-bottom: 15px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .category-tag {
      background-color: var(--accent-color);
      color: white;
      padding: 8px 15px;
      border-radius: 20px;
      font-size: 1.1em;
      font-weight: 500;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    .prompt-text {
      font-size: 1.8em;
      font-weight: 600;
      color: var(--text-color);
      margin-bottom: 20px;
    }
    .timer-container {
      display: flex;
      align-items: center;
      gap: 10px;
      background-color: var(--background-color);
      padding: 10px 20px;
      border-radius: 30px;
      box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
    }
    .timer-icon {
      font-size: 32px;
      color: var(--accent-color); /* Changed to accent color */
    }
    .timer-text {
      font-size: 2.5em;
      font-weight: bold;
      color: var(--accent-color); /* Changed to accent color */
      min-width: 40px; /* Prevent jump when numbers change */
      text-align: center;
    }
    /* New style for individual team timers */
    .team-timer-display {
      font-size: 1.5em; /* Slightly smaller than main timer */
      font-weight: bold;
      color: var(--accent-color); /* Default to accent color */
      margin-top: 5px;
      min-width: 60px; /* Ensure consistent width */
      text-align: center;
    }
    .controls {
      display: flex;
      gap: 30px; /* Reverted gap for main controls */
      margin-top: 20px;
      justify-content: center; /* Center the main controls */
    }
    .correct-button,
    .incorrect-button {
      padding: 15px;
      border-radius: 50%;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      border: none;
      cursor: pointer;
      transition: background-color 0.3s, transform 0.1s;
    }
    .correct-button {
      background-color: var(--primary-color);
      color: white;
    }
    .incorrect-button {
      background-color: var(--secondary-color);
      color: white;
    }
    .correct-button:hover {
      background-color: var(--primary-color);
      filter: brightness(1.1);
    }
    .incorrect-button:hover {
      background-color: var(--secondary-color);
      filter: brightness(1.1);
    }
    .correct-button .material-icons,
    .incorrect-button .material-icons {
      font-size: 48px;
    }
    /* New styles for team ability buttons */
    .team-abilities {
      display: flex;
      justify-content: center;
      gap: 8px; /* Smaller gap for abilities within team box */
      margin-top: 10px;
    }
    .team-ability-button {
      background-color: var(--accent-color);
      color: white;
      padding: 8px; /* Smaller padding */
      border-radius: 50%;
      border: none;
      cursor: pointer;
      transition: background-color 0.3s, transform 0.1s, opacity 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    .team-ability-button .material-icons {
      font-size: 24px; /* Smaller icons */
    }
    .team-ability-button:hover:not(:disabled) {
      filter: brightness(1.1);
      transform: translateY(-1px);
    }
    .team-ability-button:disabled {
      background-color: var(--disabled-color);
      cursor: not-allowed;
      opacity: 0.7;
      box-shadow: none;
    }
    /* Responsive adjustments for ability buttons */
    @media (max-width: 768px) {
      .team-ability-button .material-icons {
        font-size: 20px;
      }
      .team-ability-button {
        padding: 6px;
      }
    }
    @media (max-width: 480px) {
      .team-ability-button .material-icons {
        font-size: 18px;
      }
      .team-ability-button {
        padding: 5px;
      }
      .team-abilities {
        gap: 5px;
      }
    }
    /* Game Over Screen */
    .winner-message {
      font-size: 2em;
      font-weight: bold;
      color: var(--primary-color);
      margin-bottom: 20px;
    }
    /* Modal Styles */
    .modal {
      display: none; /* Hidden by default */
      position: fixed; /* Stay in place */
      z-index: 1000; /* Sit on top */
      left: 0;
      top: 0;
      width: 100%; /* Full width */
      height: 100%; /* Full height */
      overflow: auto; /* Enable scroll if needed */
      background-color: rgba(0, 0, 0, 0.4); /* Black w/ opacity */
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }
    .modal.show {
      opacity: 1;
      visibility: visible;
    }
    .modal-content {
      background-color: var(--card-background);
      margin: auto;
      padding: 30px;
      border-radius: 10px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      max-width: 400px;
      text-align: center;
      transform: translateY(-20px);
      transition: transform 0.3s ease;
    }
    .modal.show .modal-content {
      transform: translateY(0);
    }
    #modal-text {
      font-size: 1.5em;
      font-weight: bold;
      color: var(--text-color);
    }
    /* Styles for stars */
    .stars-display {
      display: flex;
      justify-content: center;
      gap: 3px; /* Smaller gap for stars */
      margin-bottom: 5px; /* Space between stars and name */
      min-height: 24px; /* Consistent height */
    }
    .star-icon {
      color: gold; /* Or any other star color */
      font-size: 20px; /* Smaller than strike icons */
    }
  </style>
</head>
<body>
  <main>
      <header>
          <h1>Team Challenge</h1>
          <button id="darkModeToggle" class="icon-button" aria-label="Toggle dark mode">
              <span class="material-icons">dark_mode</span>
          </button>
      </header>
      <section id="setup-screen" class="screen active">
          <h2>Game Setup</h2>
          <div class="form-group">
              <label for="numTeams">Number of Teams:</label>
              <select id="numTeams">
                  <option value="2">2</option>
                  <option value="3">3</option>
                  <option value="4">4</option>
              </select>
          </div>
          <div id="teamNameInputs">
              <div class="form-group">
                  <label for="team1Name">Team 1 Name:</label>
                  <input type="text" id="team1Name" value="Team Alpha" placeholder="Enter Team 1 Name">
              </div>
              <div class="form-group">
                  <label for="team2Name">Team 2 Name:</label>
                  <input type="text" id="team2Name" value="Team Beta" placeholder="Enter Team 2 Name">
              </div>
          </div>
          <button id="startGameBtn" class="button">Start Game</button>
      </section>
      <section id="game-screen" class="screen">
          <div id="teams-container">
              <!-- Team boxes will be dynamically inserted here -->
          </div>
          <div class="game-area">
              <div id="categoriesDisplayContainer" class="categories-display">
                  <!-- Categories will be dynamically inserted here -->
              </div>
              <p id="prompt" class="prompt-text"></p>
              <div class="timer-container">
                  <span class="material-icons timer-icon">timer</span>
                  <span id="timer" class="timer-text">02:00</span>
                  <button id="pauseBtn" class="icon-button team-ability-button" aria-label="Pause timer">
                      <span class="material-icons">pause</span>
                  </button>
              </div>
              <div class="controls">
                  <button id="correctBtn" class="icon-button correct-button" aria-label="Correct answer">
                      <span class="material-icons">check_circle</span>
                  </button>
                  <button id="incorrectBtn" class="icon-button incorrect-button" aria-label="Incorrect answer">
                      <span class="material-icons">cancel</span>
                  </button>
              </div>
          </div>
      </section>
      <section id="game-over-screen" class="screen">
          <h2>Game Over!</h2>
          <p id="winnerMessage" class="winner-message"></p>
          <button id="playAgainBtn" class="button">Play Again</button>
      </section>
      <div id="message-modal" class="modal">
          <div class="modal-content">
              <p id="modal-text"></p>
          </div>
      </div>
  </main>
  <!-- Sound Elements (using online free sound files) -->
  <audio id="correctSound" src="https://www.soundjay.com/buttons/button-1.mp3" preload="auto"></audio>
  <audio id="incorrectSound" src="https://www.soundjay.com/buttons/button-2.mp3" preload="auto"></audio>
  <audio id="strikeSound" src="https://www.soundjay.com/misc/fail-buzzer-01.mp3" preload="auto"></audio>
  <audio id="timerEndSound" src="https://www.soundjay.com/misc/fail-buzzer-02.mp3" preload="auto"></audio>
  <audio id="winSound" src="https://www.soundjay.com/misc/success-sound-effect.mp3" preload="auto"></audio>
  <script>
    // --- DOM Elements ---
    const setupScreen = document.getElementById("setup-screen")
    const gameScreen = document.getElementById("game-screen")
    const gameOverScreen = document.getElementById("game-over-screen")
    const numTeamsSelect = document.getElementById("numTeams")
    const teamNameInputsDiv = document.getElementById("teamNameInputs")
    const startGameBtn = document.getElementById("startGameBtn")
    const teamsContainer = document.getElementById("teams-container")
    // Changed to container for dynamic categories
    const categoriesDisplayContainer = document.getElementById("categoriesDisplayContainer")
    const promptText = document.getElementById("prompt")
    const timerDisplay = document.getElementById("timer")
    const correctBtn = document.getElementById("correctBtn")
    const incorrectBtn = document.getElementById("incorrectBtn")
    const pauseBtn = document.getElementById("pauseBtn")
    const winnerMessage = document.getElementById("winnerMessage")
    const playAgainBtn = document.getElementById("playAgainBtn")
    const darkModeToggle = document.getElementById("darkModeToggle")
    const messageModal = document.getElementById("message-modal")
    const modalText = document.getElementById("modal-text")

    // --- Game State Variables ---
    let teams = []
    let currentTeamIndex = 0
    let gameStarted = false
    let extraCategoriesActive = false; // New: Tracks if EXTRA ability is active
    let teamWhoActivatedExtra = null; // New: Stores the index of the team who activated EXTRA

    // --- Category Data (100 easy categories) ---
    const allCategoryNames = [
      "Fruits", "Animals", "Movies", "TV Series", "Car Brands", "Colors", "Kitchen Utensils", "Clothing Items", "Sports", "Musical Instruments",
      "Superheroes", "Vegetables", "Tools", "Professions", "Body Parts", "Countries", "Cities", "Famous Landmarks",
      "Mammals", "Desserts", "Drinks", "Breakfast Foods", "Lunch Foods", "Dinner Foods",
      "Dairy Products", "Seafood", "Fast Food Chains",
      "Restaurants", "School Subjects", "Hobbies", "Card Games", "Video Game Genres", "Social Media Platforms",
      "Websites", "Apps", "Musical Genres", "Dance Styles", "Art Forms", "Famous Artists", "Famous Scientists", "Historical Figures",
      "Mythological Creatures", "Fairy Tale Characters", "Cartoon Characters", "Disney Characters",
      "TV Show Genres", "Book Genres", "Authors",
      "Rooms in a House", "Furniture", "Appliances", "Weather Phenomena", "Natural Disasters", "Gemstones", "Metals", "Elements (Periodic Table)",
      "Units of Measurement", "Shapes", "Numbers", "Letters", "Feelings", "Adjectives", "Verbs", "Nouns",
      "Adverbs", "Prepositions", "Holidays", "Months", "Continents", "Oceans"
    ];
    let activeCategories = [] // e.g., ['fruits', 'carBrands']
    let availableCategoriesForSession = []; // Categories available for the entire game session

    // --- Sound Effects ---
    const soundEffects = {
      correct: document.getElementById("correctSound"),
      incorrect: document.getElementById("incorrectSound"),
      strike: document.getElementById("strikeSound"),
      timerEnd: document.getElementById("timerEndSound"),
      win: document.getElementById("winSound"),
    }

    // --- Utility Functions ---
    function showScreen(screen) {
      document.querySelectorAll(".screen").forEach((s) => s.classList.remove("active"))
      screen.classList.add("active")
    }

    function showMessage(message, duration = 2000) {
      modalText.textContent = message
      messageModal.classList.add("show")
      setTimeout(() => {
        modalText.textContent = ""; // Clear text after hiding
        messageModal.classList.remove("show")
      }, duration)
    }

    function playSound(soundName) {
      if (soundEffects[soundName]) {
        soundEffects[soundName].currentTime = 0 // Rewind to start
        soundEffects[soundName].play().catch((e) => console.error("Error playing sound:", e))
      }
    }

    function formatTime(seconds) {
      const minutes = Math.floor(seconds / 60);
      const remainingSeconds = seconds % 60;
      return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
    }

    // --- Game Setup Logic ---
    function generateTeamNameInputs(num) {
      teamNameInputsDiv.innerHTML = ""
      for (let i = 1; i <= num; i++) {
        const div = document.createElement("div")
        div.classList.add("form-group")
        div.innerHTML = `
              <label for="team${i}Name">Team ${i} Name:</label>
              <input type="text" id="team${i}Name" value="Team ${String.fromCharCode(64 + i)}" placeholder="Enter Team ${i} Name">
          `
        teamNameInputsDiv.appendChild(div)
      }
    }

    numTeamsSelect.addEventListener("change", (e) => {
      generateTeamNameInputs(Number.parseInt(e.target.value))
    })

    startGameBtn.addEventListener("click", () => {
      const numTeams = Number.parseInt(numTeamsSelect.value)
      teams = []
      let allNamesValid = true
      for (let i = 1; i <= numTeams; i++) {
        const nameInput = document.getElementById(`team${i}Name`)
        const name = nameInput.value.trim()
        if (!name) {
          allNamesValid = false
          nameInput.style.borderColor = "var(--secondary-color)"
          setTimeout(() => (nameInput.style.borderColor = "var(--border-color)"), 1500)
          showMessage(`Please enter a name for Team ${i}.`)
          return
        }
        teams.push({
          name: name,
          strikes: 0,
          stars: 0,
          isOut: false,
          hasSwitched: false,
          hasSkipped: false,
          hasExtra: false, // New: EXTRA ability usage
          individualTimeLeft: 120, // New: individual timer
          individualTimerInterval: null, // New: individual timer interval ID
          isIndividualTimerRunning: false, // New: individual timer running state
          isIndividualTimerPaused: false, // New: individual timer paused state
        })
      }
      if (allNamesValid) {
        gameStarted = true
        availableCategoriesForSession = [...allCategoryNames]; // Initialize for the session
        initGame()
        startRound()
        showScreen(gameScreen)
      }
    })

    // --- Game Core Logic ---
    function initGame() {
      currentTeamIndex = 0
      startNewRound(false); // Call startNewRound for initial setup, don't show message
      renderTeams(); // Initial render of teams with 0 strikes and 0 stars
    }

    function renderTeams() {
      teamsContainer.innerHTML = ""
      teams.forEach((team, index) => {
        const teamBox = document.createElement("div")
        teamBox.classList.add("team-box")
        teamBox.dataset.teamIndex = index
        teamBox.innerHTML = `
          <div class="stars-display"></div>
          <div class="team-name">${team.name}</div>
          <div class="strikes"></div>
          <div class="team-timer-display" data-team-timer-index="${index}"></div> <!-- Individual Team Timer -->
          <div class="team-abilities">
            <button class="team-ability-button" data-ability-type="switch" aria-label="Switch categories">
              <span class="material-icons">delete</span>
            </button>
            <button class="team-ability-button" data-ability-type="skip" aria-label="Skip turn">
              <span class="material-icons">skip_next</span>
            </button>
            <button class="team-ability-button" data-ability-type="extra" aria-label="Force extra categories on others">
              <span class="material-icons">add_circle</span>
            </button>
          </div>
        `
        teamsContainer.appendChild(teamBox)
        // Attach event listeners to the newly created buttons for this team
        teamBox.querySelector('[data-ability-type="switch"]').addEventListener("click", () => handleSwitch(index))
        teamBox.querySelector('[data-ability-type="skip"]').addEventListener("click", () => handleSkip(index))
        // New: Event listener for EXTRA ability
        teamBox.querySelector('[data-ability-type="extra"]').addEventListener("click", () => handleExtra(index))
        updateTeamBox(index) // Initial update for strikes, stars, and active state
        updateTeamTimerDisplay(index); // Initial update for individual team timer
      })
    }

    function updateTeamBox(index) {
      const teamBox = teamsContainer.querySelector(`[data-team-index="${index}"]`)
      if (!teamBox) return
      const team = teams[index]
      const strikesDiv = teamBox.querySelector(".strikes")
      const starsDiv = teamBox.querySelector(".stars-display")

      // Update strikes
      strikesDiv.innerHTML = ""
      for (let i = 0; i < team.strikes; i++) {
        const strikeIcon = document.createElement("span")
        strikeIcon.classList.add("material-icons", "strike-icon")
        strikeIcon.textContent = "close"
        strikesDiv.appendChild(strikeIcon)
      }

      // Update stars
      starsDiv.innerHTML = ""
      for (let i = 0; i < team.stars; i++) {
        const starIcon = document.createElement("span")
        starIcon.classList.add("material-icons", "star-icon")
        starIcon.textContent = "star"
        starsDiv.appendChild(starIcon)
      }

      // Highlight active team
      if (index === currentTeamIndex && !team.isOut) {
        teamBox.classList.add("active");
      } else {
        teamBox.classList.remove("active");
      }

      // Mark team as out
      if (team.isOut) {
        teamBox.classList.add("out")
      } else {
        teamBox.classList.remove("out")
      }

      // Get ability buttons for this specific team box
      const teamSwitchBtn = teamBox.querySelector('[data-ability-type="switch"]')
      const teamSkipBtn = teamBox.querySelector('[data-ability-type="skip"]')
      const teamExtraBtn = teamBox.querySelector('[data-ability-type="extra"]') // New: EXTRA button

      // Enable/disable ability buttons based on current team and usage
      // Buttons are enabled if it's the current team's turn AND they haven't used the ability yet AND the team is not out.
      // Otherwise, they are disabled.
      if (teamSwitchBtn) teamSwitchBtn.disabled = !(index === currentTeamIndex && !team.isOut && !team.hasSwitched);
      if (teamSkipBtn) teamSkipBtn.disabled = !(index === currentTeamIndex && !team.isOut && !team.hasSkipped);
      // New: Disable EXTRA button if not current team, out, or already used
      if (teamExtraBtn) teamExtraBtn.disabled = !(index === currentTeamIndex && !team.isOut && !team.hasExtra);
    }

    // New: Function to generate and set active categories based on game state
    function regenerateCategories(numToGenerate) {
        activeCategories = []; // Clear current active categories
        for (let i = 0; i < numToGenerate; i++) {
            if (availableCategoriesForSession.length === 0) {
                console.warn("Ran out of unique categories for the session!");
                // Fallback: if no more unique categories, maybe reuse from full list or end game
                const randomIndex = Math.floor(Math.random() * allCategoryNames.length);
                activeCategories.push(allCategoryNames[randomIndex]);
            } else {
                const randomIndex = Math.floor(Math.random() * availableCategoriesForSession.length);
                activeCategories.push(availableCategoriesForSession[randomIndex]);
                availableCategoriesForSession.splice(randomIndex, 1); // Remove from session pool
            }
        }
        // This function no longer calls updateCategoriesDisplay()
    }

    // New: Function to just update the display based on activeCategories
    function updateCategoriesDisplay() {
      categoriesDisplayContainer.innerHTML = ""; // Clear existing tags
      activeCategories.forEach(category => {
          const span = document.createElement("span");
          span.classList.add("category-tag");
          span.textContent = category;
          categoriesDisplayContainer.appendChild(span);
      });
      promptText.textContent = ""; // Ensure no text is displayed here
    }

    function startRound() {
      // Reset ability usage at the start of each round
      teams.forEach((team) => {
        team.hasSwitched = false
        team.hasSkipped = false
        team.hasExtra = false // New: Reset EXTRA ability
      })
      nextTurn()
    }

    // New: Start individual team timer
    function startTeamTimer(teamIndex) {
      const team = teams[teamIndex];
      if (team.isIndividualTimerRunning || team.isOut) return; // Prevent multiple intervals or starting for out teams

      team.isIndividualTimerRunning = true;
      team.isIndividualTimerPaused = false;
            
      // Only update the global pause button if it's the current team's turn
      if (teamIndex === currentTeamIndex) {
        pauseBtn.querySelector(".material-icons").textContent = "pause";
        pauseBtn.setAttribute("aria-label", "Pause timer");
      }

      team.individualTimerInterval = setInterval(() => {
        team.individualTimeLeft--;
        updateTeamTimerDisplay(teamIndex); // Update individual team's timer display
        if (teamIndex === currentTeamIndex) { // Only update global display if it's the current team
          updateTimerDisplay();
        }

        if (team.individualTimeLeft <= 0) {
          clearInterval(team.individualTimerInterval);
          team.individualTimerInterval = null;
          team.isIndividualTimerRunning = false;
          team.isIndividualTimerPaused = false; // Timer ran out, not paused
          if (teamIndex === currentTeamIndex) { // Only trigger strike if it's the current team's turn
            handleStrike(true); // Timer ran out
          }
        }
      }, 1000);
    }

    // New: Stop individual team timer
    function stopTeamTimer(teamIndex) {
      const team = teams[teamIndex];
      if (team.individualTimerInterval) {
        clearInterval(team.individualTimerInterval);
        team.individualTimerInterval = null;
      }
      team.isIndividualTimerRunning = false;
      team.isIndividualTimerPaused = true; // Explicitly paused
            
      // Only update the global pause button if it's the current team's turn
      if (teamIndex === currentTeamIndex) {
        pauseBtn.querySelector(".material-icons").textContent = "play_arrow";
        pauseBtn.setAttribute("aria-label", "Resume timer");
      }
    }

    // New: Update individual team timer display in their box
    function updateTeamTimerDisplay(teamIndex) {
      const team = teams[teamIndex];
      const teamTimerDiv = teamsContainer.querySelector(`[data-team-timer-index="${teamIndex}"]`);
      if (!teamTimerDiv) return;

      if (team.isOut) {
        teamTimerDiv.textContent = "OUT";
        teamTimerDiv.style.color = "var(--secondary-color)";
      } else {
        teamTimerDiv.textContent = formatTime(team.individualTimeLeft);
        if (team.individualTimeLeft <= 10 && team.individualTimeLeft > 0) {
          teamTimerDiv.style.color = "var(--secondary-color)";
        } else {
          teamTimerDiv.style.color = "var(--accent-color)";
        }
      }
    }

    // Update the central timer display (for the current active team)
    function updateTimerDisplay() {
      const currentTeam = teams[currentTeamIndex];
      timerDisplay.textContent = formatTime(currentTeam.individualTimeLeft);
      if (currentTeam.individualTimeLeft <= 10 && currentTeam.individualTimeLeft > 0) {
        timerDisplay.style.color = "var(--secondary-color)";
      } else {
        timerDisplay.style.color = "var(--accent-color)";
      }
    }

    function nextTurn() {
      // Stop the timer for the *previous* current team before changing turns
      if (gameStarted && teams[currentTeamIndex] && teams[currentTeamIndex].isIndividualTimerRunning) {
        stopTeamTimer(currentTeamIndex);
      }

      const totalTeams = teams.length;
      let nextIndex = (currentTeamIndex + 1) % totalTeams;
      let foundNextTeam = false;

      // Iterate through all teams to find the next active one
      for (let i = 0; i < totalTeams; i++) {
        if (!teams[nextIndex].isOut) {
          currentTeamIndex = nextIndex;
          foundNextTeam = true;
          break;
        }
        nextIndex = (nextIndex + 1) % totalTeams;
      }

      if (!foundNextTeam) {
        checkGameOver();
        return;
      }

      teams.forEach((_, index) => updateTeamBox(index)); // Update all team boxes for highlighting and button states
      
      // Determine target number of categories for the *new* current team
      let targetNumCategories = 2;
      if (extraCategoriesActive && currentTeamIndex !== teamWhoActivatedExtra) {
          targetNumCategories = 3;
      } else if (extraCategoriesActive && currentTeamIndex === teamWhoActivatedExtra) {
          // If EXTRA was active and it's now the turn of the team who activated it, reset EXTRA
          extraCategoriesActive = false;
          teamWhoActivatedExtra = null;
          // targetNumCategories remains 2 for this team
      }

      // Only regenerate categories if the *number* of categories needs to change
      // or if activeCategories is empty (e.g., first turn of a new round)
      if (activeCategories.length !== targetNumCategories || activeCategories.length === 0) {
          regenerateCategories(targetNumCategories);
      }
      updateCategoriesDisplay(); // Always update display to reflect current activeCategories

      // Update timer display for the new current team
      updateTimerDisplay();
      // Start or resume the timer for the new current team
      startTeamTimer(currentTeamIndex);
    }

    function handleCorrect() {
      playSound("correct")
      const currentTeam = teams[currentTeamIndex];
      // Add 5 seconds, capped at 120 seconds (2 minutes)
      currentTeam.individualTimeLeft = Math.min(currentTeam.individualTimeLeft + 5, 120);
      updateTeamTimerDisplay(currentTeamIndex); // Update the individual team's display
      updateTimerDisplay(); // Update the main timer display

      stopTeamTimer(currentTeamIndex); // Stop current team's timer
      // Categories should NOT change on correct answer.
      nextTurn()
    }

    function handleIncorrect() {
      playSound("incorrect")
      handleStrike(false)
    }

    function handleStrike(timerExpired) {
      const currentTeam = teams[currentTeamIndex]
      playSound("strike")
      stopTeamTimer(currentTeamIndex); // Stop current team's timer

      let message = `${currentTeam.name} got a strike!`;
      if (timerExpired) {
        currentTeam.isOut = true; // Team is out if timer expires
        message = `${currentTeam.name}'s time ran out! They are out for the round!`;
        playSound("timerEnd");
        showMessage(message, 3000); // Keep this message for timer expiration leading to elimination
      } else {
        currentTeam.strikes++; // Only add strike if not timer expired
        if (currentTeam.strikes >= 3) {
          currentTeam.isOut = true;
          message = `${currentTeam.name} is out!`;
          showMessage(message, 3000); // Keep this message for 3 strikes leading to elimination
        }
      }

      updateTeamBox(currentTeamIndex);
      updateTeamTimerDisplay(currentTeamIndex); // Update individual timer display to show "OUT" if applicable

      // Change only ONE random category after a strike
      if (activeCategories.length > 0 && availableCategoriesForSession.length > 0) {
          const categoryToReplaceIndex = Math.floor(Math.random() * activeCategories.length);
          const oldCategory = activeCategories[categoryToReplaceIndex];
          
          let newCategory;
          let attempts = 0;
          do {
              if (availableCategoriesForSession.length === 0) {
                  console.warn("No more unique categories left in the session pool!");
                  newCategory = "No More Categories"; // Fallback
                  break;
              }
              const randomIndex = Math.floor(Math.random() * availableCategoriesForSession.length);
              newCategory = availableCategoriesForSession[randomIndex];
              attempts++;
              if (attempts > 200) { // Safety break
                  console.warn("Could not find a unique new category after many attempts. Reusing a category from the full list.");
                  newCategory = allCategoryNames[Math.floor(Math.random() * allCategoryNames.length)]; // Fallback
                  break;
              }
          } while (activeCategories.includes(newCategory) || newCategory === oldCategory); // Ensure new category is different from old and not already active

          // Remove the new category from the available pool
          availableCategoriesForSession = availableCategoriesForSession.filter(cat => cat !== newCategory);
          
          // Add the old category back to the available pool if it's not "No More Categories" and not already in the pool
          if (oldCategory !== "No More Categories" && !availableCategoriesForSession.includes(oldCategory)) {
              availableCategoriesForSession.push(oldCategory);
          }

          activeCategories[categoryToReplaceIndex] = newCategory;
          updateCategoriesDisplay(); // Update the display after changing one category
      } else {
          console.warn("Not enough categories to change!");
      }

      if (currentTeam.isOut) {
        checkGameOver(); // Check if game/round is over
      } else {
        nextTurn(); // If not out, move to next turn
      }
    }

    function checkGameOver() {
      // Stop the timer for the current team if it's still running
      if (teams[currentTeamIndex] && teams[currentTeamIndex].isIndividualTimerRunning) {
        stopTeamTimer(currentTeamIndex);
      }

      const activeTeams = teams.filter((team) => !team.isOut);

      // Scenario 1: A team has reached 3 stars (overall game win)
      const winnerByStars = teams.find(team => team.stars >= 3);
      if (winnerByStars) {
        gameStarted = false;
        winnerMessage.innerHTML = `Congratulations, <span style="color: var(--primary-color);">${winnerByStars.name}</span>! You win the game with 3 stars! <span class="material-icons" style="font-size: 2em; vertical-align: middle;">star</span>`;
        playSound("win");
        showScreen(gameOverScreen);
        return; // Game over
      }

      // Scenario 2: Only one team left standing in the current round (round win)
      if (activeTeams.length === 1) {
        const roundWinner = activeTeams[0];
        roundWinner.stars++; // Award a star to the last team standing
        updateTeamBox(teams.indexOf(roundWinner)); // Update UI to show new star
        playSound("win"); // Play win sound for round
        showMessage(`${roundWinner.name} is the last team standing and gets a star!`, 3000);

        // Check if this round win also leads to overall game win
        if (roundWinner.stars >= 3) {
          gameStarted = false;
          winnerMessage.innerHTML = `Congratulations, <span style="color: var(--primary-color);">${roundWinner.name}</span>! You win the game with 3 stars! <span class="material-icons" style="font-size: 2em; vertical-align: middle;">star</span>`;
          showScreen(gameOverScreen);
        } else {
          // If not overall game win, prepare for next round
          setTimeout(() => {
            startNewRound(true); // Pass true to show "New Round!" message
          }, 3500); // Give time for message to display
        }
        return; // Round ended, transition handled
      }

      // Scenario 3: All teams eliminated (draw for the round/game)
      if (activeTeams.length === 0) {
        gameStarted = false;
        winnerMessage.textContent = "It's a draw! No teams left standing.";
        showScreen(gameOverScreen);
        return; // Game over
      }

      // Scenario 4: A team was eliminated, but multiple teams are still active in the current round.
      // In this case, the game continues in the same round, and we need to move to the next active team.
      // This is handled by the `nextTurn()` call in `handleStrike()` if `checkGameOver()` doesn't
      // result in a full state change.
    }

    function startNewRound(showMessageFlag = false) {
      // Reset strikes and 'isOut' status for all teams, but keep stars
      teams.forEach(team => {
        team.strikes = 0;
        team.isOut = false; // Bring all teams back into play
        // Reset abilities for the new round
        team.hasSwitched = false;
        team.hasSkipped = false;
        team.hasExtra = false; // New: Reset EXTRA ability
        // Reset individual timer for the new round
        team.individualTimeLeft = 120;
        if (team.individualTimerInterval) {
          clearInterval(team.individualTimerInterval);
          team.individualTimerInterval = null;
        }
        team.isIndividualTimerRunning = false;
        team.isIndividualTimerPaused = false;
      });

      // Reset global EXTRA state for new round
      extraCategoriesActive = false;
      teamWhoActivatedExtra = null;

      availableCategoriesForSession = [...allCategoryNames]; // Re-initialize for the session

      renderTeams(); // Re-render team boxes to clear strikes, activate all teams, and update ability buttons
      regenerateCategories(2); // Generate initial 2 categories for the new round
      updateCategoriesDisplay(); // Display them
      currentTeamIndex = 0;
            
      if (showMessageFlag) {
        showMessage("New Round!", 2000);
        setTimeout(() => {
          nextTurn(); // Start the first turn of the new round after message
        }, 2500);
      } else {
        // For initial game setup, just start the turn immediately
        nextTurn();
      }
    }

    // --- Ability Functions ---
    function handleSwitch(teamIndex) {
      // Ensure only the current active team can use abilities
      if (teamIndex !== currentTeamIndex) {
        showMessage("It's not your team's turn to use an ability!", 1500);
        return;
      }
      const currentTeam = teams[teamIndex];
      if (currentTeam.hasSwitched) {
        showMessage("You've already used your Switch for this round!", 1500);
        return;
      }
      if (availableCategoriesForSession.length < 2) { // Need at least 2 categories to switch both
        showMessage("Not enough unique categories left to switch!", 2000);
        return;
      }

      currentTeam.hasSwitched = true;
      updateTeamBox(teamIndex); // Disable the button

      // Replace both active categories with new ones from the session pool
      regenerateCategories(2); // Always generate 2 categories for Switch
      updateCategoriesDisplay(); // Update the display

      showMessage(`${currentTeam.name} used their Switch! New categories!`, 2000);
    }

    function handleSkip(teamIndex) {
      // Ensure only the current active team can use abilities
      if (teamIndex !== currentTeamIndex) {
        showMessage("It's not your team's turn to use an ability!", 1500);
        return;
      }
      const currentTeam = teams[teamIndex];
      if (currentTeam.hasSkipped) {
        showMessage("You've already used your Skip for this round!", 1500);
        return;
      }

      currentTeam.hasSkipped = true;
      updateTeamBox(teamIndex); // Disable the button
      stopTeamTimer(currentTeamIndex); // Pause timer
      
      // Categories should NOT change on skip.
      // The nextTurn() call will handle updating the display if the number of categories changes due to EXTRA.

      nextTurn(); // Move to next team
      showMessage(`${currentTeam.name} used their Skip!`, 1500);
    }

    // New: handleExtra ability
    function handleExtra(teamIndex) {
      // Ensure only the current active team can use abilities
      if (teamIndex !== currentTeamIndex) {
        showMessage("It's not your team's turn to use an ability!", 1500);
        return;
      }
      const currentTeam = teams[teamIndex];
      if (currentTeam.hasExtra) {
        showMessage("You've already used your EXTRA ability for this round!", 1500);
        return;
      }
      if (availableCategoriesForSession.length < 3) { // Need at least 3 categories for the effect to work
        showMessage("Not enough unique categories left for EXTRA to be effective!", 2000);
        return;
      }

      currentTeam.hasExtra = true;
      extraCategoriesActive = true;
      teamWhoActivatedExtra = teamIndex;
      updateTeamBox(teamIndex); // Disable the button

      // Categories should NOT change immediately on EXTRA, the effect applies to next players.
      // The nextTurn() call for the *next* team will pick up the 3-category logic.

      showMessage(`${currentTeam.name} used EXTRA! Other teams will face 3 categories!`, 2500);
    }

    // --- Event Listeners ---
    correctBtn.addEventListener("click", handleCorrect)
    incorrectBtn.addEventListener("click", handleIncorrect)
    pauseBtn.addEventListener("click", togglePause);

    playAgainBtn.addEventListener("click", () => {
      showScreen(setupScreen)
      generateTeamNameInputs(Number.parseInt(numTeamsSelect.value))
    })

    darkModeToggle.addEventListener("click", () => {
      document.body.classList.toggle("dark-mode")
      const icon = darkModeToggle.querySelector(".material-icons")
      if (document.body.classList.contains("dark-mode")) {
        icon.textContent = "light_mode"
        darkModeToggle.setAttribute("aria-label", "Toggle light mode")
      } else {
        icon.textContent = "dark_mode"
        darkModeToggle.setAttribute("aria-label", "Toggle dark mode")
      }
    })

    // New: Toggle pause for the current team's timer
    function togglePause() {
      const currentTeam = teams[currentTeamIndex];
      if (currentTeam.isIndividualTimerRunning) {
        stopTeamTimer(currentTeamIndex);
      } else if (currentTeam.isIndividualTimerPaused) {
        startTeamTimer(currentTeamIndex);
      } else {
        // If timer is not running and not paused (e.g., first turn), start it
        startTeamTimer(currentTeamIndex);
      }
    }

    // --- Initial Setup ---
    document.addEventListener("DOMContentLoaded", () => {
      generateTeamNameInputs(Number.parseInt(numTeamsSelect.value))
      showScreen(setupScreen)
    })
  </script>
</body>
</html>
